primOpDocs =
  [ ("*#","Low word of signed integer multiply.")
  , ("timesInt2#","Return a triple (isHighNeeded,high,low) where high and low are respectively\n   the high and low bits of the double-word result. isHighNeeded is a cheap way\n   to test if the high word is a sign-extension of the low word (isHighNeeded =\n   0#) or not (isHighNeeded = 1#).")
  , ("mulIntMayOflo#","Return non-zero if there is any possibility that the upper word of a\n    signed integer multiply might contain useful information.  Return\n    zero only if you are completely sure that no overflow can occur.\n    On a 32-bit platform, the recommended implementation is to do a\n    32 x 32 -> 64 signed multiply, and subtract result[63:32] from\n    (result[31] >>signed 31).  If this is zero, meaning that the\n    upper word is merely a sign extension of the lower one, no\n    overflow can occur.\n\n    On a 64-bit platform it is not always possible to\n    acquire the top 64 bits of the result.  Therefore, a recommended\n    implementation is to take the absolute value of both operands, and\n    return 0 iff bits[63:31] of them are zero, since that means that their\n    magnitudes fit within 31 bits, so the magnitude of the product must fit\n    into 62 bits.\n\n    If in doubt, return non-zero, but do make an effort to create the\n    correct answer for small args, since otherwise the performance of\n    @(*) :: Integer -> Integer -> Integer@ will be poor.\n   ")
  , ("quotInt#","Rounds towards zero. The behavior is undefined if the second argument is\n    zero.\n   ")
  , ("remInt#","Satisfies @('quotInt#' x y) '*#' y '+#' ('remInt#' x y) == x@. The\n    behavior is undefined if the second argument is zero.\n   ")
  , ("quotRemInt#","Rounds towards zero.")
  , ("andI#","Bitwise \"and\".")
  , ("orI#","Bitwise \"or\".")
  , ("xorI#","Bitwise \"xor\".")
  , ("notI#","Bitwise \"not\", also known as the binary complement.")
  , ("negateInt#","Unary negation.\n    Since the negative 'Int#' range extends one further than the\n    positive range, 'negateInt#' of the most negative number is an\n    identity operation. This way, 'negateInt#' is always its own inverse.")
  , ("addIntC#","Add signed integers reporting overflow.\n          First member of result is the sum truncated to an 'Int#';\n          second member is zero if the true sum fits in an 'Int#',\n          nonzero if overflow occurred (the sum is either too large\n          or too small to fit in an 'Int#').")
  , ("subIntC#","Subtract signed integers reporting overflow.\n          First member of result is the difference truncated to an 'Int#';\n          second member is zero if the true difference fits in an 'Int#',\n          nonzero if overflow occurred (the difference is either too large\n          or too small to fit in an 'Int#').")
  , ("int2Float#","Convert an 'Int#' to the corresponding 'Float#' with the same\n    integral value (up to truncation due to floating-point precision). e.g.\n    @'int2Float#' 1# == 1.0#@")
  , ("int2Double#","Convert an 'Int#' to the corresponding 'Double#' with the same\n    integral value (up to truncation due to floating-point precision). e.g.\n    @'int2Double#' 1# == 1.0##@")
  , ("word2Float#","Convert an 'Word#' to the corresponding 'Float#' with the same\n    integral value (up to truncation due to floating-point precision). e.g.\n    @'word2Float#' 1## == 1.0#@")
  , ("word2Double#","Convert an 'Word#' to the corresponding 'Double#' with the same\n    integral value (up to truncation due to floating-point precision). e.g.\n    @'word2Double#' 1## == 1.0##@")
  , ("uncheckedIShiftL#","Shift left.  Result undefined if shift amount is not\n          in the range 0 to word size - 1 inclusive.")
  , ("uncheckedIShiftRA#","Shift right arithmetic.  Result undefined if shift amount is not\n          in the range 0 to word size - 1 inclusive.")
  , ("uncheckedIShiftRL#","Shift right logical.  Result undefined if shift amount is not\n          in the range 0 to word size - 1 inclusive.")
  , ("addWordC#","Add unsigned integers reporting overflow.\n          The first element of the pair is the result.  The second element is\n          the carry flag, which is nonzero on overflow. See also 'plusWord2#'.")
  , ("subWordC#","Subtract unsigned integers reporting overflow.\n          The first element of the pair is the result.  The second element is\n          the carry flag, which is nonzero on overflow.")
  , ("plusWord2#","Add unsigned integers, with the high part (carry) in the first\n          component of the returned pair and the low part in the second\n          component of the pair. See also 'addWordC#'.")
  , ("quotRemWord2#"," Takes high word of dividend, then low word of dividend, then divisor.\n           Requires that high word < divisor.")
  , ("uncheckedShiftL#","Shift left logical.   Result undefined if shift amount is not\n          in the range 0 to word size - 1 inclusive.")
  , ("uncheckedShiftRL#","Shift right logical.   Result undefined if shift  amount is not\n          in the range 0 to word size - 1 inclusive.")
  , ("popCnt8#","Count the number of set bits in the lower 8 bits of a word.")
  , ("popCnt16#","Count the number of set bits in the lower 16 bits of a word.")
  , ("popCnt32#","Count the number of set bits in the lower 32 bits of a word.")
  , ("popCnt64#","Count the number of set bits in a 64-bit word.")
  , ("popCnt#","Count the number of set bits in a word.")
  , ("pdep8#","Deposit bits to lower 8 bits of a word at locations specified by a mask.\n\n    @since 0.5.2.0")
  , ("pdep16#","Deposit bits to lower 16 bits of a word at locations specified by a mask.\n\n    @since 0.5.2.0")
  , ("pdep32#","Deposit bits to lower 32 bits of a word at locations specified by a mask.\n\n    @since 0.5.2.0")
  , ("pdep64#","Deposit bits to a word at locations specified by a mask.\n\n    @since 0.5.2.0")
  , ("pdep#","Deposit bits to a word at locations specified by a mask, aka\n    [parallel bit deposit](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets#Parallel_bit_deposit_and_extract).\n\n    Software emulation:\n\n    > pdep :: Word -> Word -> Word\n    > pdep src mask = go 0 src mask\n    >   where\n    >     go :: Word -> Word -> Word -> Word\n    >     go result _ 0 = result\n    >     go result src mask = go newResult newSrc newMask\n    >       where\n    >         maskCtz   = countTrailingZeros mask\n    >         newResult = if testBit src 0 then setBit result maskCtz else result\n    >         newSrc    = src `shiftR` 1\n    >         newMask   = clearBit mask maskCtz\n\n    @since 0.5.2.0")
  , ("pext8#","Extract bits from lower 8 bits of a word at locations specified by a mask.\n\n    @since 0.5.2.0")
  , ("pext16#","Extract bits from lower 16 bits of a word at locations specified by a mask.\n\n    @since 0.5.2.0")
  , ("pext32#","Extract bits from lower 32 bits of a word at locations specified by a mask.\n\n    @since 0.5.2.0")
  , ("pext64#","Extract bits from a word at locations specified by a mask.\n\n    @since 0.5.2.0")
  , ("pext#","Extract bits from a word at locations specified by a mask, aka\n    [parallel bit extract](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets#Parallel_bit_deposit_and_extract).\n\n    Software emulation:\n\n    > pext :: Word -> Word -> Word\n    > pext src mask = loop 0 0 0\n    >   where\n    >     loop i count result\n    >       | i >= finiteBitSize (0 :: Word)\n    >       = result\n    >       | testBit mask i\n    >       = loop (i + 1) (count + 1) (if testBit src i then setBit result count else result)\n    >       | otherwise\n    >       = loop (i + 1) count result\n\n    @since 0.5.2.0")
  , ("clz8#","Count leading zeros in the lower 8 bits of a word.")
  , ("clz16#","Count leading zeros in the lower 16 bits of a word.")
  , ("clz32#","Count leading zeros in the lower 32 bits of a word.")
  , ("clz64#","Count leading zeros in a 64-bit word.")
  , ("clz#","Count leading zeros in a word.")
  , ("ctz8#","Count trailing zeros in the lower 8 bits of a word.")
  , ("ctz16#","Count trailing zeros in the lower 16 bits of a word.")
  , ("ctz32#","Count trailing zeros in the lower 32 bits of a word.")
  , ("ctz64#","Count trailing zeros in a 64-bit word.")
  , ("ctz#","Count trailing zeros in a word.")
  , ("byteSwap16#","Swap bytes in the lower 16 bits of a word. The higher bytes are undefined. ")
  , ("byteSwap32#","Swap bytes in the lower 32 bits of a word. The higher bytes are undefined. ")
  , ("byteSwap64#","Swap bytes in a 64 bits of a word.")
  , ("byteSwap#","Swap bytes in a word.")
  , ("bitReverse8#","Reverse the order of the bits in a 8-bit word.")
  , ("bitReverse16#","Reverse the order of the bits in a 16-bit word.")
  , ("bitReverse32#","Reverse the order of the bits in a 32-bit word.")
  , ("bitReverse64#","Reverse the order of the bits in a 64-bit word.")
  , ("bitReverse#","Reverse the order of the bits in a word.")
  , ("double2Int#","Truncates a 'Double#' value to the nearest 'Int#'.\n    Results are undefined if the truncation if truncation yields\n    a value outside the range of 'Int#'.")
  , ("**##","Exponentiation.")
  , ("decodeDouble_2Int#","Convert to integer.\n    First component of the result is -1 or 1, indicating the sign of the\n    mantissa. The next two are the high and low 32 bits of the mantissa\n    respectively, and the last is the exponent.")
  , ("decodeDouble_Int64#","Decode 'Double#' into mantissa and base-2 exponent.")
  , ("castDoubleToWord64#","Bitcast a 'Double#' into a 'Word64#'")
  , ("castWord64ToDouble#","Bitcast a 'Word64#' into a 'Double#'")
  , ("float2Int#","Truncates a 'Float#' value to the nearest 'Int#'.\n    Results are undefined if the truncation if truncation yields\n    a value outside the range of 'Int#'.")
  , ("decodeFloat_Int#","Convert to integers.\n    First 'Int#' in result is the mantissa; second is the exponent.")
  , ("castFloatToWord32#","Bitcast a 'Float#' into a 'Word32#'")
  , ("castWord32ToFloat#","Bitcast a 'Word32#' into a 'Float#'")
  , ("fmaddFloat#","Fused multiply-add operation @x*y+z@. See \"GHC.Prim#fma\".")
  , ("fmsubFloat#","Fused multiply-subtract operation @x*y-z@. See \"GHC.Prim#fma\".")
  , ("fnmaddFloat#","Fused negate-multiply-add operation @-x*y+z@. See \"GHC.Prim#fma\".")
  , ("fnmsubFloat#","Fused negate-multiply-subtract operation @-x*y-z@. See \"GHC.Prim#fma\".")
  , ("fmaddDouble#","Fused multiply-add operation @x*y+z@. See \"GHC.Prim#fma\".")
  , ("fmsubDouble#","Fused multiply-subtract operation @x*y-z@. See \"GHC.Prim#fma\".")
  , ("fnmaddDouble#","Fused negate-multiply-add operation @-x*y+z@. See \"GHC.Prim#fma\".")
  , ("fnmsubDouble#","Fused negate-multiply-subtract operation @-x*y-z@. See \"GHC.Prim#fma\".")
  , ("newArray#","Create a new mutable array with the specified number of elements,\n    in the specified state thread,\n    with each element containing the specified initial value.")
  , ("readArray#","Read from specified index of mutable array. Result is not yet evaluated.")
  , ("writeArray#","Write to specified index of mutable array.")
  , ("sizeofArray#","Return the number of elements in the array.")
  , ("sizeofMutableArray#","Return the number of elements in the array.")
  , ("indexArray#","Read from the specified index of an immutable array. The result is packaged\n    into an unboxed unary tuple; the result itself is not yet\n    evaluated. Pattern matching on the tuple forces the indexing of the\n    array to happen but does not evaluate the element itself. Evaluating\n    the thunk prevents additional thunks from building up on the\n    heap. Avoiding these thunks, in turn, reduces references to the\n    argument array, allowing it to be garbage collected more promptly.")
  , ("unsafeFreezeArray#","Make a mutable array immutable, without copying.")
  , ("unsafeThawArray#","Make an immutable array mutable, without copying.")
  , ("copyArray#","Given a source array, an offset into the source array, a\n   destination array, an offset into the destination array, and a\n   number of elements to copy, copy the elements from the source array\n   to the destination array. Both arrays must fully contain the\n   specified ranges, but this is not checked. The two arrays must not\n   be the same array in different states, but this is not checked\n   either.")
  , ("copyMutableArray#","Given a source array, an offset into the source array, a\n   destination array, an offset into the destination array, and a\n   number of elements to copy, copy the elements from the source array\n   to the destination array. Both arrays must fully contain the\n   specified ranges, but this is not checked. In the case where\n   the source and destination are the same array the source and\n   destination regions may overlap.")
  , ("cloneArray#","Given a source array, an offset into the source array, and a number\n   of elements to copy, create a new array with the elements from the\n   source array. The provided array must fully contain the specified\n   range, but this is not checked.")
  , ("cloneMutableArray#","Given a source array, an offset into the source array, and a number\n   of elements to copy, create a new array with the elements from the\n   source array. The provided array must fully contain the specified\n   range, but this is not checked.")
  , ("freezeArray#","Given a source array, an offset into the source array, and a number\n   of elements to copy, create a new array with the elements from the\n   source array. The provided array must fully contain the specified\n   range, but this is not checked.")
  , ("thawArray#","Given a source array, an offset into the source array, and a number\n   of elements to copy, create a new array with the elements from the\n   source array. The provided array must fully contain the specified\n   range, but this is not checked.")
  , ("casArray#","Given an array, an offset, the expected old value, and\n    the new value, perform an atomic compare and swap (i.e. write the new\n    value if the current value and the old value are the same pointer).\n    Returns 0 if the swap succeeds and 1 if it fails. Additionally, returns\n    the element at the offset after the operation completes. This means that\n    on a success the new value is returned, and on a failure the actual old\n    value (not the expected one) is returned. Implies a full memory barrier.\n    The use of a pointer equality on a boxed value makes this function harder\n    to use correctly than 'casIntArray#'. All of the difficulties\n    of using 'reallyUnsafePtrEquality#' correctly apply to\n    'casArray#' as well.\n   ")
  , ("newSmallArray#","Create a new mutable array with the specified number of elements,\n    in the specified state thread,\n    with each element containing the specified initial value.")
  , ("shrinkSmallMutableArray#","Shrink mutable array to new specified size, in\n    the specified state thread. The new size argument must be less than or\n    equal to the current size as reported by 'getSizeofSmallMutableArray#'.\n\n    Assuming the non-profiling RTS, for the copying garbage collector\n    (default) this primitive compiles to an O(1) operation in C--, modifying\n    the array in-place. For the non-moving garbage collector, however, the\n    time is proportional to the number of elements shrinked out. Backends\n    bypassing C-- representation (such as JavaScript) might behave\n    differently.\n\n    @since 0.6.1")
  , ("readSmallArray#","Read from specified index of mutable array. Result is not yet evaluated.")
  , ("writeSmallArray#","Write to specified index of mutable array.")
  , ("sizeofSmallArray#","Return the number of elements in the array.")
  , ("sizeofSmallMutableArray#","Return the number of elements in the array. __Deprecated__, it is\n   unsafe in the presence of 'shrinkSmallMutableArray#' and @resizeSmallMutableArray#@\n   operations on the same small mutable array.")
  , ("getSizeofSmallMutableArray#","Return the number of elements in the array, correctly accounting for\n   the effect of 'shrinkSmallMutableArray#' and @resizeSmallMutableArray#@.\n\n   @since 0.6.1")
  , ("indexSmallArray#","Read from specified index of immutable array. Result is packaged into\n    an unboxed singleton; the result itself is not yet evaluated.")
  , ("unsafeFreezeSmallArray#","Make a mutable array immutable, without copying.")
  , ("unsafeThawSmallArray#","Make an immutable array mutable, without copying.")
  , ("copySmallArray#","Given a source array, an offset into the source array, a\n   destination array, an offset into the destination array, and a\n   number of elements to copy, copy the elements from the source array\n   to the destination array. Both arrays must fully contain the\n   specified ranges, but this is not checked. The two arrays must not\n   be the same array in different states, but this is not checked\n   either.")
  , ("copySmallMutableArray#","Given a source array, an offset into the source array, a\n   destination array, an offset into the destination array, and a\n   number of elements to copy, copy the elements from the source array\n   to the destination array. The source and destination arrays can\n   refer to the same array. Both arrays must fully contain the\n   specified ranges, but this is not checked.\n   The regions are allowed to overlap, although this is only possible when the same\n   array is provided as both the source and the destination. ")
  , ("cloneSmallArray#","Given a source array, an offset into the source array, and a number\n   of elements to copy, create a new array with the elements from the\n   source array. The provided array must fully contain the specified\n   range, but this is not checked.")
  , ("cloneSmallMutableArray#","Given a source array, an offset into the source array, and a number\n   of elements to copy, create a new array with the elements from the\n   source array. The provided array must fully contain the specified\n   range, but this is not checked.")
  , ("freezeSmallArray#","Given a source array, an offset into the source array, and a number\n   of elements to copy, create a new array with the elements from the\n   source array. The provided array must fully contain the specified\n   range, but this is not checked.")
  , ("thawSmallArray#","Given a source array, an offset into the source array, and a number\n   of elements to copy, create a new array with the elements from the\n   source array. The provided array must fully contain the specified\n   range, but this is not checked.")
  , ("casSmallArray#","Unsafe, machine-level atomic compare and swap on an element within an array.\n    See the documentation of 'casArray#'.")
  , ("ByteArray#","\n  A boxed, unlifted datatype representing a region of raw memory in the garbage-collected heap,\n  which is not scanned for pointers during garbage collection.\n\n  It is created by freezing a 'MutableByteArray#' with 'unsafeFreezeByteArray#'.\n  Freezing is essentially a no-op, as 'MutableByteArray#' and 'ByteArray#' share the same heap structure under the hood.\n\n  The immutable and mutable variants are commonly used for scenarios requiring high-performance data structures,\n  like @Text@, @Primitive Vector@, @Unboxed Array@, and @ShortByteString@.\n\n  Another application of fundamental importance is 'Integer', which is backed by 'ByteArray#'.\n\n  The representation on the heap of a Byte Array is:\n\n  > +------------+-----------------+-----------------------+\n  > |            |                 |                       |\n  > |   HEADER   | SIZE (in bytes) |       PAYLOAD         |\n  > |            |                 |                       |\n  > +------------+-----------------+-----------------------+\n\n  To obtain a pointer to actual payload (e.g., for FFI purposes) use 'byteArrayContents#' or 'mutableByteArrayContents#'.\n\n  Alternatively, enabling the @UnliftedFFITypes@ extension\n  allows to mention 'ByteArray#' and 'MutableByteArray#' in FFI type signatures directly.\n")
  , ("MutableByteArray#"," A mutable 'ByteAray#'. It can be created in three ways:\n\n  * 'newByteArray#': Create an unpinned array.\n  * 'newPinnedByteArray#': This will create a pinned array,\n  * 'newAlignedPinnedByteArray#': This will create a pinned array, with a custom alignment.\n\n  Unpinned arrays can be moved around during garbage collection, so you must not store or pass pointers to these values\n  if there is a chance for the garbage collector to kick in. That said, even unpinned arrays can be passed to unsafe FFI calls,\n  because no garbage collection happens during these unsafe calls\n  (see [Guaranteed Call Safety](https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/ffi.html#guaranteed-call-safety)\n  in the GHC Manual). For safe FFI calls, byte arrays must be not only pinned, but also kept alive by means of the keepAlive# function\n  for the duration of a call (that's because garbage collection cannot move a pinned array, but is free to scrap it altogether).\n")
  , ("newByteArray#","Create a new mutable byte array of specified size (in bytes), in\n    the specified state thread. The size of the memory underlying the\n    array will be rounded up to the platform's word size.")
  , ("newPinnedByteArray#","Like 'newByteArray#' but GC guarantees not to move it.")
  , ("newAlignedPinnedByteArray#","Like 'newPinnedByteArray#' but allow specifying an arbitrary\n    alignment, which must be a power of two.")
  , ("isMutableByteArrayPinned#","Determine whether a 'MutableByteArray#' is guaranteed not to move\n   during GC.")
  , ("isByteArrayPinned#","Determine whether a 'ByteArray#' is guaranteed not to move during GC.")
  , ("byteArrayContents#","Intended for use with pinned arrays; otherwise very unsafe!")
  , ("mutableByteArrayContents#","Intended for use with pinned arrays; otherwise very unsafe!")
  , ("shrinkMutableByteArray#","Shrink mutable byte array to new specified size (in bytes), in\n    the specified state thread. The new size argument must be less than or\n    equal to the current size as reported by 'getSizeofMutableByteArray#'.\n\n    Assuming the non-profiling RTS, this primitive compiles to an O(1)\n    operation in C--, modifying the array in-place. Backends bypassing C--\n    representation (such as JavaScript) might behave differently.\n\n    @since 0.4.0.0")
  , ("resizeMutableByteArray#","Resize mutable byte array to new specified size (in bytes), shrinking or growing it.\n    The returned 'MutableByteArray#' is either the original\n    'MutableByteArray#' resized in-place or, if not possible, a newly\n    allocated (unpinned) 'MutableByteArray#' (with the original content\n    copied over).\n\n    To avoid undefined behaviour, the original 'MutableByteArray#' shall\n    not be accessed anymore after a 'resizeMutableByteArray#' has been\n    performed.  Moreover, no reference to the old one should be kept in order\n    to allow garbage collection of the original 'MutableByteArray#' in\n    case a new 'MutableByteArray#' had to be allocated.\n\n    @since 0.4.0.0")
  , ("unsafeFreezeByteArray#","Make a mutable byte array immutable, without copying.")
  , ("unsafeThawByteArray#","Make an immutable byte array mutable, without copying.\n\n    @since 0.12.0.0")
  , ("sizeofByteArray#","Return the size of the array in bytes.")
  , ("sizeofMutableByteArray#","Return the size of the array in bytes. __Deprecated__, it is\n   unsafe in the presence of 'shrinkMutableByteArray#' and 'resizeMutableByteArray#'\n   operations on the same mutable byte\n   array.")
  , ("getSizeofMutableByteArray#","Return the number of elements in the array, correctly accounting for\n   the effect of 'shrinkMutableByteArray#' and 'resizeMutableByteArray#'.\n\n   @since 0.5.0.0")
  , ("indexCharArray#","Read an 8-bit character; offset in bytes.")
  , ("indexWideCharArray#","Read a 32-bit character; offset in 4-byte words.")
  , ("indexIntArray#","Read a word-sized integer; offset in machine words.")
  , ("indexWordArray#","Read a word-sized unsigned integer; offset in machine words.")
  , ("indexAddrArray#","Read a machine address; offset in machine words.")
  , ("indexFloatArray#","Read a single-precision floating-point value; offset in 4-byte words.")
  , ("indexDoubleArray#","Read a double-precision floating-point value; offset in 8-byte words.")
  , ("indexStablePtrArray#","Read a 'StablePtr#' value; offset in machine words.")
  , ("indexInt8Array#","Read an 8-bit signed integer; offset in bytes.")
  , ("indexWord8Array#","Read an 8-bit unsigned integer; offset in bytes.")
  , ("indexInt16Array#","Read a 16-bit signed integer; offset in 2-byte words.")
  , ("indexWord16Array#","Read a 16-bit unsigned integer; offset in 2-byte words.")
  , ("indexInt32Array#","Read a 32-bit signed integer; offset in 4-byte words.")
  , ("indexWord32Array#","Read a 32-bit unsigned integer; offset in 4-byte words.")
  , ("indexInt64Array#","Read a 64-bit signed integer; offset in 8-byte words.")
  , ("indexWord64Array#","Read a 64-bit unsigned integer; offset in 8-byte words.")
  , ("indexWord8ArrayAsChar#","Read an 8-bit character; offset in bytes.")
  , ("indexWord8ArrayAsWideChar#","Read a 32-bit character; offset in bytes.")
  , ("indexWord8ArrayAsInt#","Read a word-sized integer; offset in bytes.")
  , ("indexWord8ArrayAsWord#","Read a word-sized unsigned integer; offset in bytes.")
  , ("indexWord8ArrayAsAddr#","Read a machine address; offset in bytes.")
  , ("indexWord8ArrayAsFloat#","Read a single-precision floating-point value; offset in bytes.")
  , ("indexWord8ArrayAsDouble#","Read a double-precision floating-point value; offset in bytes.")
  , ("indexWord8ArrayAsStablePtr#","Read a 'StablePtr#' value; offset in bytes.")
  , ("indexWord8ArrayAsInt16#","Read a 16-bit signed integer; offset in bytes.")
  , ("indexWord8ArrayAsWord16#","Read a 16-bit unsigned integer; offset in bytes.")
  , ("indexWord8ArrayAsInt32#","Read a 32-bit signed integer; offset in bytes.")
  , ("indexWord8ArrayAsWord32#","Read a 32-bit unsigned integer; offset in bytes.")
  , ("indexWord8ArrayAsInt64#","Read a 64-bit signed integer; offset in bytes.")
  , ("indexWord8ArrayAsWord64#","Read a 64-bit unsigned integer; offset in bytes.")
  , ("readCharArray#","Read an 8-bit character; offset in bytes.")
  , ("readWideCharArray#","Read a 32-bit character; offset in 4-byte words.")
  , ("readIntArray#","Read a word-sized integer; offset in machine words.")
  , ("readWordArray#","Read a word-sized unsigned integer; offset in machine words.")
  , ("readAddrArray#","Read a machine address; offset in machine words.")
  , ("readFloatArray#","Read a single-precision floating-point value; offset in 4-byte words.")
  , ("readDoubleArray#","Read a double-precision floating-point value; offset in 8-byte words.")
  , ("readStablePtrArray#","Read a 'StablePtr#' value; offset in machine words.")
  , ("readInt8Array#","Read an 8-bit signed integer; offset in bytes.")
  , ("readWord8Array#","Read an 8-bit unsigned integer; offset in bytes.")
  , ("readInt16Array#","Read a 16-bit signed integer; offset in 2-byte words.")
  , ("readWord16Array#","Read a 16-bit unsigned integer; offset in 2-byte words.")
  , ("readInt32Array#","Read a 32-bit signed integer; offset in 4-byte words.")
  , ("readWord32Array#","Read a 32-bit unsigned integer; offset in 4-byte words.")
  , ("readInt64Array#","Read a 64-bit signed integer; offset in 8-byte words.")
  , ("readWord64Array#","Read a 64-bit unsigned integer; offset in 8-byte words.")
  , ("readWord8ArrayAsChar#","Read an 8-bit character; offset in bytes.")
  , ("readWord8ArrayAsWideChar#","Read a 32-bit character; offset in bytes.")
  , ("readWord8ArrayAsInt#","Read a word-sized integer; offset in bytes.")
  , ("readWord8ArrayAsWord#","Read a word-sized unsigned integer; offset in bytes.")
  , ("readWord8ArrayAsAddr#","Read a machine address; offset in bytes.")
  , ("readWord8ArrayAsFloat#","Read a single-precision floating-point value; offset in bytes.")
  , ("readWord8ArrayAsDouble#","Read a double-precision floating-point value; offset in bytes.")
  , ("readWord8ArrayAsStablePtr#","Read a 'StablePtr#' value; offset in bytes.")
  , ("readWord8ArrayAsInt16#","Read a 16-bit signed integer; offset in bytes.")
  , ("readWord8ArrayAsWord16#","Read a 16-bit unsigned integer; offset in bytes.")
  , ("readWord8ArrayAsInt32#","Read a 32-bit signed integer; offset in bytes.")
  , ("readWord8ArrayAsWord32#","Read a 32-bit unsigned integer; offset in bytes.")
  , ("readWord8ArrayAsInt64#","Read a 64-bit signed integer; offset in bytes.")
  , ("readWord8ArrayAsWord64#","Read a 64-bit unsigned integer; offset in bytes.")
  , ("writeCharArray#","Write an 8-bit character; offset in bytes.")
  , ("writeWideCharArray#","Write a 32-bit character; offset in 4-byte words.")
  , ("writeIntArray#","Write a word-sized integer; offset in machine words.")
  , ("writeWordArray#","Write a word-sized unsigned integer; offset in machine words.")
  , ("writeAddrArray#","Write a machine address; offset in machine words.")
  , ("writeFloatArray#","Write a single-precision floating-point value; offset in 4-byte words.")
  , ("writeDoubleArray#","Write a double-precision floating-point value; offset in 8-byte words.")
  , ("writeStablePtrArray#","Write a 'StablePtr#' value; offset in machine words.")
  , ("writeInt8Array#","Write an 8-bit signed integer; offset in bytes.")
  , ("writeWord8Array#","Write an 8-bit unsigned integer; offset in bytes.")
  , ("writeInt16Array#","Write a 16-bit signed integer; offset in 2-byte words.")
  , ("writeWord16Array#","Write a 16-bit unsigned integer; offset in 2-byte words.")
  , ("writeInt32Array#","Write a 32-bit signed integer; offset in 4-byte words.")
  , ("writeWord32Array#","Write a 32-bit unsigned integer; offset in 4-byte words.")
  , ("writeInt64Array#","Write a 64-bit signed integer; offset in 8-byte words.")
  , ("writeWord64Array#","Write a 64-bit unsigned integer; offset in 8-byte words.")
  , ("writeWord8ArrayAsChar#","Write an 8-bit character; offset in bytes.")
  , ("writeWord8ArrayAsWideChar#","Write a 32-bit character; offset in bytes.")
  , ("writeWord8ArrayAsInt#","Write a word-sized integer; offset in bytes.")
  , ("writeWord8ArrayAsWord#","Write a word-sized unsigned integer; offset in bytes.")
  , ("writeWord8ArrayAsAddr#","Write a machine address; offset in bytes.")
  , ("writeWord8ArrayAsFloat#","Write a single-precision floating-point value; offset in bytes.")
  , ("writeWord8ArrayAsDouble#","Write a double-precision floating-point value; offset in bytes.")
  , ("writeWord8ArrayAsStablePtr#","Write a 'StablePtr#' value; offset in bytes.")
  , ("writeWord8ArrayAsInt16#","Write a 16-bit signed integer; offset in bytes.")
  , ("writeWord8ArrayAsWord16#","Write a 16-bit unsigned integer; offset in bytes.")
  , ("writeWord8ArrayAsInt32#","Write a 32-bit signed integer; offset in bytes.")
  , ("writeWord8ArrayAsWord32#","Write a 32-bit unsigned integer; offset in bytes.")
  , ("writeWord8ArrayAsInt64#","Write a 64-bit signed integer; offset in bytes.")
  , ("writeWord8ArrayAsWord64#","Write a 64-bit unsigned integer; offset in bytes.")
  , ("compareByteArrays#","@'compareByteArrays#' src1 src1_ofs src2 src2_ofs n@ compares\n    @n@ bytes starting at offset @src1_ofs@ in the first\n    'ByteArray#' @src1@ to the range of @n@ bytes\n    (i.e. same length) starting at offset @src2_ofs@ of the second\n    'ByteArray#' @src2@.  Both arrays must fully contain the\n    specified ranges, but this is not checked.  Returns an 'Int#'\n    less than, equal to, or greater than zero if the range is found,\n    respectively, to be byte-wise lexicographically less than, to\n    match, or be greater than the second range.\n\n    @since 0.5.2.0")
  , ("copyByteArray#"," @'copyByteArray#' src src_ofs dst dst_ofs len@ copies the range\n    starting at offset @src_ofs@ of length @len@ from the\n    'ByteArray#' @src@ to the 'MutableByteArray#' @dst@\n    starting at offset @dst_ofs@.  Both arrays must fully contain\n    the specified ranges, but this is not checked.  The two arrays must\n    not be the same array in different states, but this is not checked\n    either.\n  ")
  , ("copyMutableByteArray#"," @'copyMutableByteArray#' src src_ofs dst dst_ofs len@ copies the\n    range starting at offset @src_ofs@ of length @len@ from the\n    'MutableByteArray#' @src@ to the 'MutableByteArray#' @dst@\n    starting at offset @dst_ofs@.  Both arrays must fully contain the\n    specified ranges, but this is not checked.  The regions are\n    allowed to overlap, although this is only possible when the same\n    array is provided as both the source and the destination.\n  ")
  , ("copyMutableByteArrayNonOverlapping#"," @'copyMutableByteArrayNonOverlapping#' src src_ofs dst dst_ofs len@\n    copies the range starting at offset @src_ofs@ of length @len@ from\n    the 'MutableByteArray#' @src@ to the 'MutableByteArray#' @dst@\n    starting at offset @dst_ofs@.  Both arrays must fully contain the\n    specified ranges, but this is not checked.  The regions are /not/\n    allowed to overlap, but this is also not checked.\n\n    @since 0.11.0\n  ")
  , ("copyByteArrayToAddr#","Copy a range of the ByteArray\\# to the memory range starting at the Addr\\#.\n   The ByteArray\\# and the memory region at Addr\\# must fully contain the\n   specified ranges, but this is not checked. The Addr\\# must not point into the\n   ByteArray\\# (e.g. if the ByteArray\\# were pinned), but this is not checked\n   either.")
  , ("copyMutableByteArrayToAddr#","Copy a range of the MutableByteArray\\# to the memory range starting at the\n   Addr\\#. The MutableByteArray\\# and the memory region at Addr\\# must fully\n   contain the specified ranges, but this is not checked. The Addr\\# must not\n   point into the MutableByteArray\\# (e.g. if the MutableByteArray\\# were\n   pinned), but this is not checked either.")
  , ("copyAddrToByteArray#","Copy a memory range starting at the Addr\\# to the specified range in the\n   MutableByteArray\\#. The memory region at Addr\\# and the ByteArray\\# must fully\n   contain the specified ranges, but this is not checked. The Addr\\# must not\n   point into the MutableByteArray\\# (e.g. if the MutableByteArray\\# were pinned),\n   but this is not checked either.")
  , ("copyAddrToAddr#"," @'copyAddrToAddr#' src dest len@ copies @len@ bytes\n    from @src@ to @dest@.  These two memory ranges are allowed to overlap.\n\n    Analogous to the standard C function @memmove@, but with a different\n    argument order.\n\n    @since 0.11.0\n  ")
  , ("copyAddrToAddrNonOverlapping#"," @'copyAddrToAddrNonOverlapping#' src dest len@ copies @len@ bytes\n    from @src@ to @dest@.  As the name suggests, these two memory ranges\n    /must not overlap/, although this pre-condition is not checked.\n\n    Analogous to the standard C function @memcpy@, but with a different\n    argument order.\n\n    @since 0.11.0\n  ")
  , ("setByteArray#","@'setByteArray#' ba off len c@ sets the byte range @[off, off+len)@ of\n   the 'MutableByteArray#' to the byte @c@.")
  , ("setAddrRange#"," @'setAddrRange#' dest len c@ sets all of the bytes in\n    @[dest, dest+len)@ to the value @c@.\n\n    Analogous to the standard C function @memset@, but with a different\n    argument order.\n\n    @since 0.11.0\n  ")
  , ("atomicReadIntArray#","Given an array and an offset in machine words, read an element. The\n    index is assumed to be in bounds. Implies a full memory barrier.")
  , ("atomicWriteIntArray#","Given an array and an offset in machine words, write an element. The\n    index is assumed to be in bounds. Implies a full memory barrier.")
  , ("casIntArray#","Given an array, an offset in machine words, the expected old value, and\n    the new value, perform an atomic compare and swap i.e. write the new\n    value if the current value matches the provided old value. Returns\n    the value of the element before the operation. Implies a full memory\n    barrier.")
  , ("casInt8Array#","Given an array, an offset in bytes, the expected old value, and\n    the new value, perform an atomic compare and swap i.e. write the new\n    value if the current value matches the provided old value. Returns\n    the value of the element before the operation. Implies a full memory\n    barrier.")
  , ("casInt16Array#","Given an array, an offset in 16 bit units, the expected old value, and\n    the new value, perform an atomic compare and swap i.e. write the new\n    value if the current value matches the provided old value. Returns\n    the value of the element before the operation. Implies a full memory\n    barrier.")
  , ("casInt32Array#","Given an array, an offset in 32 bit units, the expected old value, and\n    the new value, perform an atomic compare and swap i.e. write the new\n    value if the current value matches the provided old value. Returns\n    the value of the element before the operation. Implies a full memory\n    barrier.")
  , ("casInt64Array#","Given an array, an offset in 64 bit units, the expected old value, and\n    the new value, perform an atomic compare and swap i.e. write the new\n    value if the current value matches the provided old value. Returns\n    the value of the element before the operation. Implies a full memory\n    barrier.")
  , ("fetchAddIntArray#","Given an array, and offset in machine words, and a value to add,\n    atomically add the value to the element. Returns the value of the\n    element before the operation. Implies a full memory barrier.")
  , ("fetchSubIntArray#","Given an array, and offset in machine words, and a value to subtract,\n    atomically subtract the value from the element. Returns the value of\n    the element before the operation. Implies a full memory barrier.")
  , ("fetchAndIntArray#","Given an array, and offset in machine words, and a value to AND,\n    atomically AND the value into the element. Returns the value of the\n    element before the operation. Implies a full memory barrier.")
  , ("fetchNandIntArray#","Given an array, and offset in machine words, and a value to NAND,\n    atomically NAND the value into the element. Returns the value of the\n    element before the operation. Implies a full memory barrier.")
  , ("fetchOrIntArray#","Given an array, and offset in machine words, and a value to OR,\n    atomically OR the value into the element. Returns the value of the\n    element before the operation. Implies a full memory barrier.")
  , ("fetchXorIntArray#","Given an array, and offset in machine words, and a value to XOR,\n    atomically XOR the value into the element. Returns the value of the\n    element before the operation. Implies a full memory barrier.")
  , ("Addr#"," An arbitrary machine address assumed to point outside\n         the garbage-collected heap. ")
  , ("nullAddr#"," The null address. ")
  , ("minusAddr#","Result is meaningless if two 'Addr#'s are so far apart that their\n         difference doesn't fit in an 'Int#'.")
  , ("remAddr#","Return the remainder when the 'Addr#' arg, treated like an 'Int#',\n          is divided by the 'Int#' arg.")
  , ("addr2Int#","Coerce directly from address to int.")
  , ("int2Addr#","Coerce directly from int to address.")
  , ("indexCharOffAddr#","Read an 8-bit character; offset in bytes.\n\n")
  , ("indexWideCharOffAddr#","Read a 32-bit character; offset in 4-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("indexIntOffAddr#","Read a word-sized integer; offset in machine words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("indexWordOffAddr#","Read a word-sized unsigned integer; offset in machine words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("indexAddrOffAddr#","Read a machine address; offset in machine words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("indexFloatOffAddr#","Read a single-precision floating-point value; offset in 4-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("indexDoubleOffAddr#","Read a double-precision floating-point value; offset in 8-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("indexStablePtrOffAddr#","Read a 'StablePtr#' value; offset in machine words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("indexInt8OffAddr#","Read an 8-bit signed integer; offset in bytes.\n\n")
  , ("indexWord8OffAddr#","Read an 8-bit unsigned integer; offset in bytes.\n\n")
  , ("indexInt16OffAddr#","Read a 16-bit signed integer; offset in 2-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("indexWord16OffAddr#","Read a 16-bit unsigned integer; offset in 2-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("indexInt32OffAddr#","Read a 32-bit signed integer; offset in 4-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("indexWord32OffAddr#","Read a 32-bit unsigned integer; offset in 4-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("indexInt64OffAddr#","Read a 64-bit signed integer; offset in 8-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("indexWord64OffAddr#","Read a 64-bit unsigned integer; offset in 8-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("indexWord8OffAddrAsChar#","Read an 8-bit character; offset in bytes.")
  , ("indexWord8OffAddrAsWideChar#","Read a 32-bit character; offset in bytes.")
  , ("indexWord8OffAddrAsInt#","Read a word-sized integer; offset in bytes.")
  , ("indexWord8OffAddrAsWord#","Read a word-sized unsigned integer; offset in bytes.")
  , ("indexWord8OffAddrAsAddr#","Read a machine address; offset in bytes.")
  , ("indexWord8OffAddrAsFloat#","Read a single-precision floating-point value; offset in bytes.")
  , ("indexWord8OffAddrAsDouble#","Read a double-precision floating-point value; offset in bytes.")
  , ("indexWord8OffAddrAsStablePtr#","Read a 'StablePtr#' value; offset in bytes.")
  , ("indexWord8OffAddrAsInt16#","Read a 16-bit signed integer; offset in bytes.")
  , ("indexWord8OffAddrAsWord16#","Read a 16-bit unsigned integer; offset in bytes.")
  , ("indexWord8OffAddrAsInt32#","Read a 32-bit signed integer; offset in bytes.")
  , ("indexWord8OffAddrAsWord32#","Read a 32-bit unsigned integer; offset in bytes.")
  , ("indexWord8OffAddrAsInt64#","Read a 64-bit signed integer; offset in bytes.")
  , ("indexWord8OffAddrAsWord64#","Read a 64-bit unsigned integer; offset in bytes.")
  , ("readCharOffAddr#","Read an 8-bit character; offset in bytes.\n\n")
  , ("readWideCharOffAddr#","Read a 32-bit character; offset in 4-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("readIntOffAddr#","Read a word-sized integer; offset in machine words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("readWordOffAddr#","Read a word-sized unsigned integer; offset in machine words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("readAddrOffAddr#","Read a machine address; offset in machine words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("readFloatOffAddr#","Read a single-precision floating-point value; offset in 4-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("readDoubleOffAddr#","Read a double-precision floating-point value; offset in 8-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("readStablePtrOffAddr#","Read a 'StablePtr#' value; offset in machine words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("readInt8OffAddr#","Read an 8-bit signed integer; offset in bytes.\n\n")
  , ("readWord8OffAddr#","Read an 8-bit unsigned integer; offset in bytes.\n\n")
  , ("readInt16OffAddr#","Read a 16-bit signed integer; offset in 2-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("readWord16OffAddr#","Read a 16-bit unsigned integer; offset in 2-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("readInt32OffAddr#","Read a 32-bit signed integer; offset in 4-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("readWord32OffAddr#","Read a 32-bit unsigned integer; offset in 4-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("readInt64OffAddr#","Read a 64-bit signed integer; offset in 8-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("readWord64OffAddr#","Read a 64-bit unsigned integer; offset in 8-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("readWord8OffAddrAsChar#","Read an 8-bit character; offset in bytes.")
  , ("readWord8OffAddrAsWideChar#","Read a 32-bit character; offset in bytes.")
  , ("readWord8OffAddrAsInt#","Read a word-sized integer; offset in bytes.")
  , ("readWord8OffAddrAsWord#","Read a word-sized unsigned integer; offset in bytes.")
  , ("readWord8OffAddrAsAddr#","Read a machine address; offset in bytes.")
  , ("readWord8OffAddrAsFloat#","Read a single-precision floating-point value; offset in bytes.")
  , ("readWord8OffAddrAsDouble#","Read a double-precision floating-point value; offset in bytes.")
  , ("readWord8OffAddrAsStablePtr#","Read a 'StablePtr#' value; offset in bytes.")
  , ("readWord8OffAddrAsInt16#","Read a 16-bit signed integer; offset in bytes.")
  , ("readWord8OffAddrAsWord16#","Read a 16-bit unsigned integer; offset in bytes.")
  , ("readWord8OffAddrAsInt32#","Read a 32-bit signed integer; offset in bytes.")
  , ("readWord8OffAddrAsWord32#","Read a 32-bit unsigned integer; offset in bytes.")
  , ("readWord8OffAddrAsInt64#","Read a 64-bit signed integer; offset in bytes.")
  , ("readWord8OffAddrAsWord64#","Read a 64-bit unsigned integer; offset in bytes.")
  , ("writeCharOffAddr#","Write an 8-bit character; offset in bytes.\n\n")
  , ("writeWideCharOffAddr#","Write a 32-bit character; offset in 4-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("writeIntOffAddr#","Write a word-sized integer; offset in machine words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("writeWordOffAddr#","Write a word-sized unsigned integer; offset in machine words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("writeAddrOffAddr#","Write a machine address; offset in machine words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("writeFloatOffAddr#","Write a single-precision floating-point value; offset in 4-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("writeDoubleOffAddr#","Write a double-precision floating-point value; offset in 8-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("writeStablePtrOffAddr#","Write a 'StablePtr#' value; offset in machine words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("writeInt8OffAddr#","Write an 8-bit signed integer; offset in bytes.\n\n")
  , ("writeWord8OffAddr#","Write an 8-bit unsigned integer; offset in bytes.\n\n")
  , ("writeInt16OffAddr#","Write a 16-bit signed integer; offset in 2-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("writeWord16OffAddr#","Write a 16-bit unsigned integer; offset in 2-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("writeInt32OffAddr#","Write a 32-bit signed integer; offset in 4-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("writeWord32OffAddr#","Write a 32-bit unsigned integer; offset in 4-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("writeInt64OffAddr#","Write a 64-bit signed integer; offset in 8-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("writeWord64OffAddr#","Write a 64-bit unsigned integer; offset in 8-byte words.\n\nOn some platforms, the access may fail\nfor an insufficiently aligned @Addr#@.")
  , ("writeWord8OffAddrAsChar#","Write an 8-bit character; offset in bytes.")
  , ("writeWord8OffAddrAsWideChar#","Write a 32-bit character; offset in bytes.")
  , ("writeWord8OffAddrAsInt#","Write a word-sized integer; offset in bytes.")
  , ("writeWord8OffAddrAsWord#","Write a word-sized unsigned integer; offset in bytes.")
  , ("writeWord8OffAddrAsAddr#","Write a machine address; offset in bytes.")
  , ("writeWord8OffAddrAsFloat#","Write a single-precision floating-point value; offset in bytes.")
  , ("writeWord8OffAddrAsDouble#","Write a double-precision floating-point value; offset in bytes.")
  , ("writeWord8OffAddrAsStablePtr#","Write a 'StablePtr#' value; offset in bytes.")
  , ("writeWord8OffAddrAsInt16#","Write a 16-bit signed integer; offset in bytes.")
  , ("writeWord8OffAddrAsWord16#","Write a 16-bit unsigned integer; offset in bytes.")
  , ("writeWord8OffAddrAsInt32#","Write a 32-bit signed integer; offset in bytes.")
  , ("writeWord8OffAddrAsWord32#","Write a 32-bit unsigned integer; offset in bytes.")
  , ("writeWord8OffAddrAsInt64#","Write a 64-bit signed integer; offset in bytes.")
  , ("writeWord8OffAddrAsWord64#","Write a 64-bit unsigned integer; offset in bytes.")
  , ("atomicExchangeAddrAddr#","The atomic exchange operation. Atomically exchanges the value at the first address\n    with the Addr# given as second argument. Implies a read barrier.")
  , ("atomicExchangeWordAddr#","The atomic exchange operation. Atomically exchanges the value at the address\n    with the given value. Returns the old value. Implies a read barrier.")
  , ("atomicCasAddrAddr#"," Compare and swap on a word-sized memory location.\n\n     Use as: \\s -> atomicCasAddrAddr# location expected desired s\n\n     This version always returns the old value read. This follows the normal\n     protocol for CAS operations (and matches the underlying instruction on\n     most architectures).\n\n     Implies a full memory barrier.")
  , ("atomicCasWordAddr#"," Compare and swap on a word-sized and aligned memory location.\n\n     Use as: \\s -> atomicCasWordAddr# location expected desired s\n\n     This version always returns the old value read. This follows the normal\n     protocol for CAS operations (and matches the underlying instruction on\n     most architectures).\n\n     Implies a full memory barrier.")
  , ("atomicCasWord8Addr#"," Compare and swap on a 8 bit-sized and aligned memory location.\n\n     Use as: \\s -> atomicCasWordAddr8# location expected desired s\n\n     This version always returns the old value read. This follows the normal\n     protocol for CAS operations (and matches the underlying instruction on\n     most architectures).\n\n     Implies a full memory barrier.")
  , ("atomicCasWord16Addr#"," Compare and swap on a 16 bit-sized and aligned memory location.\n\n     Use as: \\s -> atomicCasWordAddr16# location expected desired s\n\n     This version always returns the old value read. This follows the normal\n     protocol for CAS operations (and matches the underlying instruction on\n     most architectures).\n\n     Implies a full memory barrier.")
  , ("atomicCasWord32Addr#"," Compare and swap on a 32 bit-sized and aligned memory location.\n\n     Use as: \\s -> atomicCasWordAddr32# location expected desired s\n\n     This version always returns the old value read. This follows the normal\n     protocol for CAS operations (and matches the underlying instruction on\n     most architectures).\n\n     Implies a full memory barrier.")
  , ("atomicCasWord64Addr#"," Compare and swap on a 64 bit-sized and aligned memory location.\n\n     Use as: \\s -> atomicCasWordAddr64# location expected desired s\n\n     This version always returns the old value read. This follows the normal\n     protocol for CAS operations (and matches the underlying instruction on\n     most architectures).\n\n     Implies a full memory barrier.")
  , ("fetchAddWordAddr#","Given an address, and a value to add,\n    atomically add the value to the element. Returns the value of the\n    element before the operation. Implies a full memory barrier.")
  , ("fetchSubWordAddr#","Given an address, and a value to subtract,\n    atomically subtract the value from the element. Returns the value of\n    the element before the operation. Implies a full memory barrier.")
  , ("fetchAndWordAddr#","Given an address, and a value to AND,\n    atomically AND the value into the element. Returns the value of the\n    element before the operation. Implies a full memory barrier.")
  , ("fetchNandWordAddr#","Given an address, and a value to NAND,\n    atomically NAND the value into the element. Returns the value of the\n    element before the operation. Implies a full memory barrier.")
  , ("fetchOrWordAddr#","Given an address, and a value to OR,\n    atomically OR the value into the element. Returns the value of the\n    element before the operation. Implies a full memory barrier.")
  , ("fetchXorWordAddr#","Given an address, and a value to XOR,\n    atomically XOR the value into the element. Returns the value of the\n    element before the operation. Implies a full memory barrier.")
  , ("atomicReadWordAddr#","Given an address, read a machine word.  Implies a full memory barrier.")
  , ("atomicWriteWordAddr#","Given an address, write a machine word. Implies a full memory barrier.")
  , ("MutVar#","A 'MutVar#' behaves like a single-element mutable array.")
  , ("newMutVar#","Create 'MutVar#' with specified initial value in specified state thread.")
  , ("readMutVar#","Read contents of 'MutVar#'. Result is not yet evaluated.")
  , ("writeMutVar#","Write contents of 'MutVar#'.")
  , ("atomicSwapMutVar#","Atomically exchange the value of a 'MutVar#'.")
  , ("atomicModifyMutVar2#"," Modify the contents of a 'MutVar#', returning the previous\n     contents @x :: a@ and the result of applying the given function to the\n     previous contents @f x :: c@.\n\n     The @data@ type @c@ (not a @newtype@!) must be a record whose first field\n     is of lifted type @a :: Type@ and is not unpacked. For example, product\n     types @c ~ Solo a@ or @c ~ (a, b)@ work well. If the record type is both\n     monomorphic and strict in its first field, it's recommended to mark the\n     latter @{-# NOUNPACK #-}@ explicitly.\n\n     Under the hood 'atomicModifyMutVar2#' atomically replaces a pointer to an\n     old @x :: a@ with a pointer to a selector thunk @fst r@, where\n     @fst@ is a selector for the first field of the record and @r@ is a\n     function application thunk @r = f x@.\n\n     @atomicModifyIORef2Native@ from @atomic-modify-general@ package makes an\n     effort to reflect restrictions on @c@ faithfully, providing a\n     well-typed high-level wrapper.")
  , ("atomicModifyMutVar_#"," Modify the contents of a 'MutVar#', returning the previous\n     contents and the result of applying the given function to the\n     previous contents. ")
  , ("casMutVar#"," Compare-and-swap: perform a pointer equality test between\n     the first value passed to this function and the value\n     stored inside the 'MutVar#'. If the pointers are equal,\n     replace the stored value with the second value passed to this\n     function, otherwise do nothing.\n     Returns the final value stored inside the 'MutVar#'.\n     The 'Int#' indicates whether a swap took place,\n     with @1#@ meaning that we didn't swap, and @0#@\n     that we did.\n     Implies a full memory barrier.\n     Because the comparison is done on the level of pointers,\n     all of the difficulties of using\n     'reallyUnsafePtrEquality#' correctly apply to\n     'casMutVar#' as well.\n   ")
  , ("catch#"," @'catch#' k handler s@ evaluates @k s@, invoking @handler@ on any exceptions\n     thrown.\n\n     Note that the result type here isn't quite as unrestricted as the\n     polymorphic type might suggest; see the section \\\"RuntimeRep polymorphism\n     in continuation-style primops\\\" for details. ")
  , ("maskAsyncExceptions#"," @'maskAsyncExceptions#' k s@ evaluates @k s@ such that asynchronous\n     exceptions are deferred until after evaluation has finished.\n\n     Note that the result type here isn't quite as unrestricted as the\n     polymorphic type might suggest; see the section \\\"RuntimeRep polymorphism\n     in continuation-style primops\\\" for details. ")
  , ("maskUninterruptible#"," @'maskUninterruptible#' k s@ evaluates @k s@ such that asynchronous\n     exceptions are deferred until after evaluation has finished.\n\n     Note that the result type here isn't quite as unrestricted as the\n     polymorphic type might suggest; see the section \\\"RuntimeRep polymorphism\n     in continuation-style primops\\\" for details. ")
  , ("unmaskAsyncExceptions#"," @'unmaskAsyncUninterruptible#' k s@ evaluates @k s@ such that asynchronous\n     exceptions are unmasked.\n\n     Note that the result type here isn't quite as unrestricted as the\n     polymorphic type might suggest; see the section \\\"RuntimeRep polymorphism\n     in continuation-style primops\\\" for details. ")
  , ("PromptTag#"," See \"GHC.Prim#continuations\". ")
  , ("newPromptTag#"," See \"GHC.Prim#continuations\". ")
  , ("prompt#"," See \"GHC.Prim#continuations\". ")
  , ("control0#"," See \"GHC.Prim#continuations\". ")
  , ("newTVar#","Create a new 'TVar#' holding a specified initial value.")
  , ("readTVar#","Read contents of 'TVar#' inside an STM transaction,\n    i.e. within a call to 'atomically#'.\n    Does not force evaluation of the result.")
  , ("readTVarIO#","Read contents of 'TVar#' outside an STM transaction.\n   Does not force evaluation of the result.")
  , ("writeTVar#","Write contents of 'TVar#'.")
  , ("MVar#"," A shared mutable variable (/not/ the same as a 'MutVar#'!).\n        (Note: in a non-concurrent implementation, @('MVar#' a)@ can be\n        represented by @('MutVar#' (Maybe a))@.) ")
  , ("newMVar#","Create new 'MVar#'; initially empty.")
  , ("takeMVar#","If 'MVar#' is empty, block until it becomes full.\n   Then remove and return its contents, and set it empty.")
  , ("tryTakeMVar#","If 'MVar#' is empty, immediately return with integer 0 and value undefined.\n   Otherwise, return with integer 1 and contents of 'MVar#', and set 'MVar#' empty.")
  , ("putMVar#","If 'MVar#' is full, block until it becomes empty.\n   Then store value arg as its new contents.")
  , ("tryPutMVar#","If 'MVar#' is full, immediately return with integer 0.\n    Otherwise, store value arg as 'MVar#''s new contents, and return with integer 1.")
  , ("readMVar#","If 'MVar#' is empty, block until it becomes full.\n   Then read its contents without modifying the MVar, without possibility\n   of intervention from other threads.")
  , ("tryReadMVar#","If 'MVar#' is empty, immediately return with integer 0 and value undefined.\n   Otherwise, return with integer 1 and contents of 'MVar#'.")
  , ("isEmptyMVar#","Return 1 if 'MVar#' is empty; 0 otherwise.")
  , ("IOPort#"," A shared I/O port is almost the same as an 'MVar#'.\n        The main difference is that IOPort has no deadlock detection or\n        deadlock breaking code that forcibly releases the lock. ")
  , ("newIOPort#","Create new 'IOPort#'; initially empty.")
  , ("readIOPort#","If 'IOPort#' is empty, block until it becomes full.\n   Then remove and return its contents, and set it empty.\n   Throws an 'IOPortException' if another thread is already\n   waiting to read this 'IOPort#'.")
  , ("writeIOPort#","If 'IOPort#' is full, immediately return with integer 0,\n    throwing an 'IOPortException'.\n    Otherwise, store value arg as 'IOPort#''s new contents,\n    and return with integer 1. ")
  , ("delay#","Sleep specified number of microseconds.")
  , ("waitRead#","Block until input is available on specified file descriptor.")
  , ("waitWrite#","Block until output is possible on specified file descriptor.")
  , ("State#"," 'State#' is the primitive, unlifted type of states.  It has\n        one type parameter, thus @'State#' 'RealWorld'@, or @'State#' s@,\n        where s is a type variable. The only purpose of the type parameter\n        is to keep different state threads separate.  It is represented by\n        nothing at all. ")
  , ("RealWorld"," 'RealWorld' is deeply magical.  It is /primitive/, but it is not\n        /unlifted/ (hence @ptrArg@).  We never manipulate values of type\n        'RealWorld'; it's only used in the type system, to parameterise 'State#'. ")
  , ("ThreadId#","(In a non-concurrent implementation, this can be a singleton\n        type, whose (unique) value is returned by 'myThreadId#'.  The\n        other operations can be omitted.)")
  , ("labelThread#","Set the label of the given thread. The @ByteArray#@ should contain\n    a UTF-8-encoded string.")
  , ("threadLabel#","Get the label of the given thread.\n    Morally of type @ThreadId# -> IO (Maybe ByteArray#)@, with a @1#@ tag\n    denoting @Just@.\n\n    @since 0.10")
  , ("threadStatus#","Get the status of the given thread. Result is\n    @(ThreadStatus, Capability, Locked)@ where\n    @ThreadStatus@ is one of the status constants defined in\n    @rts/Constants.h@, @Capability@ is the number of\n    the capability which currently owns the thread, and\n    @Locked@ is a boolean indicating whether the\n    thread is bound to that capability.\n\n    @since 0.9")
  , ("listThreads#"," Returns an array of the threads started by the program. Note that this\n     threads which have finished execution may or may not be present in this\n     list, depending upon whether they have been collected by the garbage collector.\n\n     @since 0.10")
  , ("mkWeak#"," @'mkWeak#' k v finalizer s@ creates a weak reference to value @k@,\n     with an associated reference to some value @v@. If @k@ is still\n     alive then @v@ can be retrieved using 'deRefWeak#'. Note that\n     the type of @k@ must be represented by a pointer (i.e. of kind\n     @'TYPE' ''LiftedRep' or @'TYPE' ''UnliftedRep'@). ")
  , ("addCFinalizerToWeak#"," @'addCFinalizerToWeak#' fptr ptr flag eptr w@ attaches a C\n     function pointer @fptr@ to a weak pointer @w@ as a finalizer. If\n     @flag@ is zero, @fptr@ will be called with one argument,\n     @ptr@. Otherwise, it will be called with two arguments,\n     @eptr@ and @ptr@. 'addCFinalizerToWeak#' returns\n     1 on success, or 0 if @w@ is already dead. ")
  , ("finalizeWeak#"," Finalize a weak pointer. The return value is an unboxed tuple\n     containing the new state of the world and an \"unboxed Maybe\",\n     represented by an 'Int#' and a (possibly invalid) finalization\n     action. An 'Int#' of @1@ indicates that the finalizer is valid. The\n     return value @b@ from the finalizer should be ignored. ")
  , ("compactNew#"," Create a new CNF with a single compact block. The argument is\n     the capacity of the compact block (in bytes, not words).\n     The capacity is rounded up to a multiple of the allocator block size\n     and is capped to one mega block. ")
  , ("compactResize#"," Set the new allocation size of the CNF. This value (in bytes)\n     determines the capacity of each compact block in the CNF. It\n     does not retroactively affect existing compact blocks in the CNF. ")
  , ("compactContains#"," Returns 1\\# if the object is contained in the CNF, 0\\# otherwise. ")
  , ("compactContainsAny#"," Returns 1\\# if the object is in any CNF at all, 0\\# otherwise. ")
  , ("compactGetFirstBlock#"," Returns the address and the utilized size (in bytes) of the\n     first compact block of a CNF.")
  , ("compactGetNextBlock#"," Given a CNF and the address of one its compact blocks, returns the\n     next compact block and its utilized size, or 'nullAddr#' if the\n     argument was the last compact block in the CNF. ")
  , ("compactAllocateBlock#"," Attempt to allocate a compact block with the capacity (in\n     bytes) given by the first argument. The 'Addr#' is a pointer\n     to previous compact block of the CNF or 'nullAddr#' to create a\n     new CNF with a single compact block.\n\n     The resulting block is not known to the GC until\n     'compactFixupPointers#' is called on it, and care must be taken\n     so that the address does not escape or memory will be leaked.\n   ")
  , ("compactFixupPointers#"," Given the pointer to the first block of a CNF and the\n     address of the root object in the old address space, fix up\n     the internal pointers inside the CNF to account for\n     a different position in memory than when it was serialized.\n     This method must be called exactly once after importing\n     a serialized CNF. It returns the new CNF and the new adjusted\n     root address. ")
  , ("compactAdd#"," Recursively add a closure and its transitive closure to a\n     'Compact#' (a CNF), evaluating any unevaluated components\n     at the same time. Note: 'compactAdd#' is not thread-safe, so\n     only one thread may call 'compactAdd#' with a particular\n     'Compact#' at any given time. The primop does not\n     enforce any mutual exclusion; the caller is expected to\n     arrange this. ")
  , ("compactAddWithSharing#"," Like 'compactAdd#', but retains sharing and cycles\n   during compaction. ")
  , ("compactSize#"," Return the total capacity (in bytes) of all the compact blocks\n     in the CNF. ")
  , ("reallyUnsafePtrEquality#"," Returns @1#@ if the given pointers are equal and @0#@ otherwise. ")
  , ("numSparks#"," Returns the number of sparks in the local spark pool. ")
  , ("keepAlive#"," @'keepAlive#' x s k@ keeps the value @x@ alive during the execution\n     of the computation @k@.\n\n     Note that the result type here isn't quite as unrestricted as the\n     polymorphic type might suggest; see the section \\\"RuntimeRep polymorphism\n     in continuation-style primops\\\" for details. ")
  , ("dataToTagSmall#"," Used internally to implement @dataToTag#@: Use that function instead!\n     This one normally offers /no advantage/ and comes with no stability\n     guarantees: it may change its type, its name, or its behavior\n     with /no warning/ between compiler releases.\n\n     It is expected that this function will be un-exposed in a future\n     release of ghc.\n\n     For more details, look at @Note [DataToTag overview]@\n     in GHC.Tc.Instance.Class in the source code for\n     /the specific compiler version you are using./\n   ")
  , ("dataToTagLarge#"," Used internally to implement @dataToTag#@: Use that function instead!\n     This one offers /no advantage/ and comes with no stability\n     guarantees: it may change its type, its name, or its behavior\n     with /no warning/ between compiler releases.\n\n     It is expected that this function will be un-exposed in a future\n     release of ghc.\n\n     For more details, look at @Note [DataToTag overview]@\n     in GHC.Tc.Instance.Class in the source code for\n     /the specific compiler version you are using./\n   ")
  , ("BCO"," Primitive bytecode type. ")
  , ("addrToAny#"," Convert an 'Addr#' to a followable Any type. ")
  , ("anyToAddr#"," Retrieve the address of any Haskell value. This is\n     essentially an 'unsafeCoerce#', but if implemented as such\n     the core lint pass complains and fails to compile.\n     As a primop, it is opaque to core/stg, and only appears\n     in cmm (where the copy propagation pass will get rid of it).\n     Note that \"a\" must be a value, not a thunk! It's too late\n     for strictness analysis to enforce this, so you're on your\n     own to guarantee this. Also note that 'Addr#' is not a GC\n     pointer - up to you to guarantee that it does not become\n     a dangling pointer immediately after you get it.")
  , ("mkApUpd0#"," Wrap a BCO in a @AP_UPD@ thunk which will be updated with the value of\n     the BCO when evaluated. ")
  , ("newBCO#"," @'newBCO#' instrs lits ptrs arity bitmap@ creates a new bytecode object. The\n     resulting object encodes a function of the given arity with the instructions\n     encoded in @instrs@, and a static reference table usage bitmap given by\n     @bitmap@. ")
  , ("unpackClosure#"," @'unpackClosure#' closure@ copies the closure and pointers in the\n     payload of the given closure into two new arrays, and returns a pointer to\n     the first word of the closure's info table, a non-pointer array for the raw\n     bytes of the closure, and a pointer array for the pointers in the payload. ")
  , ("closureSize#"," @'closureSize#' closure@ returns the size of the given closure in\n     machine words. ")
  , ("getCurrentCCS#"," Returns the current 'CostCentreStack' (value is @NULL@ if\n     not profiling).  Takes a dummy argument which can be used to\n     avoid the call to 'getCurrentCCS#' being floated out by the\n     simplifier, which would result in an uninformative stack\n     (\"CAF\"). ")
  , ("clearCCS#"," Run the supplied IO action with an empty CCS.  For example, this\n     is used by the interpreter to run an interpreted computation\n     without the call stack showing that it was invoked from GHC. ")
  , ("whereFrom#"," Fills the given buffer with the @InfoProvEnt@ for the info table of the\n     given object. Returns @1#@ on success and @0#@ otherwise.")
  , ("FUN","The builtin function type, written in infix form as @a % m -> b@.\n   Values of this type are functions taking inputs of type @a@ and\n   producing outputs of type @b@. The multiplicity of the input is\n   @m@.\n\n   Note that @'FUN' m a b@ permits representation polymorphism in both\n   @a@ and @b@, so that types like @'Int#' -> 'Int#'@ can still be\n   well-kinded.\n  ")
  , ("realWorld#"," The token used in the implementation of the IO monad as a state monad.\n     It does not pass any information at runtime.\n     See also 'GHC.Magic.runRW#'. ")
  , ("void#"," This is an alias for the unboxed unit tuple constructor.\n     In earlier versions of GHC, 'void#' was a value\n     of the primitive type 'Void#', which is now defined to be @(# #)@.\n   ")
  , ("Proxy#"," The type constructor 'Proxy#' is used to bear witness to some\n   type variable. It's used when you want to pass around proxy values\n   for doing things like modelling type applications. A 'Proxy#'\n   is not only unboxed, it also has a polymorphic kind, and has no\n   runtime representation, being totally free. ")
  , ("proxy#"," Witness for an unboxed 'Proxy#' value, which has no runtime\n   representation. ")
  , ("seq"," The value of @'seq' a b@ is bottom if @a@ is bottom, and\n     otherwise equal to @b@. In other words, it evaluates the first\n     argument @a@ to weak head normal form (WHNF). 'seq' is usually\n     introduced to improve performance by avoiding unneeded laziness.\n\n     A note on evaluation order: the expression @'seq' a b@ does\n     /not/ guarantee that @a@ will be evaluated before @b@.\n     The only guarantee given by 'seq' is that the both @a@\n     and @b@ will be evaluated before 'seq' returns a value.\n     In particular, this means that @b@ may be evaluated before\n     @a@. If you need to guarantee a specific order of evaluation,\n     you must use the function 'pseq' from the \"parallel\" package. ")
  , ("traceEvent#"," Emits an event via the RTS tracing framework.  The contents\n     of the event is the zero-terminated byte string passed as the first\n     argument.  The event will be emitted either to the @.eventlog@ file,\n     or to stderr, depending on the runtime RTS flags. ")
  , ("traceBinaryEvent#"," Emits an event via the RTS tracing framework.  The contents\n     of the event is the binary object passed as the first argument with\n     the given length passed as the second argument. The event will be\n     emitted to the @.eventlog@ file. ")
  , ("traceMarker#"," Emits a marker event via the RTS tracing framework.  The contents\n     of the event is the zero-terminated byte string passed as the first\n     argument.  The event will be emitted either to the @.eventlog@ file,\n     or to stderr, depending on the runtime RTS flags. ")
  , ("setThreadAllocationCounter#"," Sets the allocation counter for the current thread to the given value. ")
  , ("StackSnapshot#"," Haskell representation of a @StgStack*@ that was created (cloned)\n     with a function in \"GHC.Stack.CloneStack\". Please check the\n     documentation in that module for more detailed explanations. ")
  , ("coerce"," The function 'coerce' allows you to safely convert between values of\n     types that have the same representation with no run-time overhead. In the\n     simplest case you can use it instead of a newtype constructor, to go from\n     the newtype's concrete type to the abstract type. But it also works in\n     more complicated settings, e.g. converting a list of newtypes to a list of\n     concrete types.\n\n     When used in conversions involving a newtype wrapper,\n     make sure the newtype constructor is in scope.\n\n     This function is representation-polymorphic, but the\n     'RuntimeRep' type argument is marked as 'Inferred', meaning\n     that it is not available for visible type application. This means\n     the typechecker will accept @'coerce' \\@'Int' \\@Age 42@.\n\n     === __Examples__\n\n     >>> newtype TTL = TTL Int deriving (Eq, Ord, Show)\n     >>> newtype Age = Age Int deriving (Eq, Ord, Show)\n     >>> coerce (Age 42) :: TTL\n     TTL 42\n     >>> coerce (+ (1 :: Int)) (Age 42) :: TTL\n     TTL 43\n     >>> coerce (map (+ (1 :: Int))) [Age 42, Age 24] :: [TTL]\n     [TTL 43,TTL 25]\n\n   ")
  , ("broadcastInt8X16#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastInt16X8#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastInt32X4#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastInt64X2#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastInt8X32#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastInt16X16#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastInt32X8#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastInt64X4#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastInt8X64#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastInt16X32#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastInt32X16#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastInt64X8#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastWord8X16#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastWord16X8#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastWord32X4#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastWord64X2#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastWord8X32#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastWord16X16#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastWord32X8#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastWord64X4#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastWord8X64#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastWord16X32#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastWord32X16#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastWord64X8#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastFloatX4#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastDoubleX2#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastFloatX8#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastDoubleX4#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastFloatX16#"," Broadcast a scalar to all elements of a vector. ")
  , ("broadcastDoubleX8#"," Broadcast a scalar to all elements of a vector. ")
  , ("packInt8X16#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packInt16X8#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packInt32X4#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packInt64X2#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packInt8X32#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packInt16X16#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packInt32X8#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packInt64X4#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packInt8X64#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packInt16X32#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packInt32X16#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packInt64X8#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packWord8X16#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packWord16X8#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packWord32X4#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packWord64X2#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packWord8X32#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packWord16X16#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packWord32X8#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packWord64X4#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packWord8X64#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packWord16X32#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packWord32X16#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packWord64X8#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packFloatX4#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packDoubleX2#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packFloatX8#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packDoubleX4#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packFloatX16#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("packDoubleX8#"," Pack the elements of an unboxed tuple into a vector. ")
  , ("unpackInt8X16#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackInt16X8#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackInt32X4#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackInt64X2#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackInt8X32#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackInt16X16#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackInt32X8#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackInt64X4#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackInt8X64#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackInt16X32#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackInt32X16#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackInt64X8#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackWord8X16#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackWord16X8#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackWord32X4#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackWord64X2#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackWord8X32#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackWord16X16#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackWord32X8#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackWord64X4#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackWord8X64#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackWord16X32#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackWord32X16#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackWord64X8#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackFloatX4#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackDoubleX2#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackFloatX8#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackDoubleX4#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackFloatX16#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("unpackDoubleX8#"," Unpack the elements of a vector into an unboxed tuple. #")
  , ("insertInt8X16#"," Insert a scalar at the given position in a vector. ")
  , ("insertInt16X8#"," Insert a scalar at the given position in a vector. ")
  , ("insertInt32X4#"," Insert a scalar at the given position in a vector. ")
  , ("insertInt64X2#"," Insert a scalar at the given position in a vector. ")
  , ("insertInt8X32#"," Insert a scalar at the given position in a vector. ")
  , ("insertInt16X16#"," Insert a scalar at the given position in a vector. ")
  , ("insertInt32X8#"," Insert a scalar at the given position in a vector. ")
  , ("insertInt64X4#"," Insert a scalar at the given position in a vector. ")
  , ("insertInt8X64#"," Insert a scalar at the given position in a vector. ")
  , ("insertInt16X32#"," Insert a scalar at the given position in a vector. ")
  , ("insertInt32X16#"," Insert a scalar at the given position in a vector. ")
  , ("insertInt64X8#"," Insert a scalar at the given position in a vector. ")
  , ("insertWord8X16#"," Insert a scalar at the given position in a vector. ")
  , ("insertWord16X8#"," Insert a scalar at the given position in a vector. ")
  , ("insertWord32X4#"," Insert a scalar at the given position in a vector. ")
  , ("insertWord64X2#"," Insert a scalar at the given position in a vector. ")
  , ("insertWord8X32#"," Insert a scalar at the given position in a vector. ")
  , ("insertWord16X16#"," Insert a scalar at the given position in a vector. ")
  , ("insertWord32X8#"," Insert a scalar at the given position in a vector. ")
  , ("insertWord64X4#"," Insert a scalar at the given position in a vector. ")
  , ("insertWord8X64#"," Insert a scalar at the given position in a vector. ")
  , ("insertWord16X32#"," Insert a scalar at the given position in a vector. ")
  , ("insertWord32X16#"," Insert a scalar at the given position in a vector. ")
  , ("insertWord64X8#"," Insert a scalar at the given position in a vector. ")
  , ("insertFloatX4#"," Insert a scalar at the given position in a vector. ")
  , ("insertDoubleX2#"," Insert a scalar at the given position in a vector. ")
  , ("insertFloatX8#"," Insert a scalar at the given position in a vector. ")
  , ("insertDoubleX4#"," Insert a scalar at the given position in a vector. ")
  , ("insertFloatX16#"," Insert a scalar at the given position in a vector. ")
  , ("insertDoubleX8#"," Insert a scalar at the given position in a vector. ")
  , ("plusInt8X16#"," Add two vectors element-wise. ")
  , ("plusInt16X8#"," Add two vectors element-wise. ")
  , ("plusInt32X4#"," Add two vectors element-wise. ")
  , ("plusInt64X2#"," Add two vectors element-wise. ")
  , ("plusInt8X32#"," Add two vectors element-wise. ")
  , ("plusInt16X16#"," Add two vectors element-wise. ")
  , ("plusInt32X8#"," Add two vectors element-wise. ")
  , ("plusInt64X4#"," Add two vectors element-wise. ")
  , ("plusInt8X64#"," Add two vectors element-wise. ")
  , ("plusInt16X32#"," Add two vectors element-wise. ")
  , ("plusInt32X16#"," Add two vectors element-wise. ")
  , ("plusInt64X8#"," Add two vectors element-wise. ")
  , ("plusWord8X16#"," Add two vectors element-wise. ")
  , ("plusWord16X8#"," Add two vectors element-wise. ")
  , ("plusWord32X4#"," Add two vectors element-wise. ")
  , ("plusWord64X2#"," Add two vectors element-wise. ")
  , ("plusWord8X32#"," Add two vectors element-wise. ")
  , ("plusWord16X16#"," Add two vectors element-wise. ")
  , ("plusWord32X8#"," Add two vectors element-wise. ")
  , ("plusWord64X4#"," Add two vectors element-wise. ")
  , ("plusWord8X64#"," Add two vectors element-wise. ")
  , ("plusWord16X32#"," Add two vectors element-wise. ")
  , ("plusWord32X16#"," Add two vectors element-wise. ")
  , ("plusWord64X8#"," Add two vectors element-wise. ")
  , ("plusFloatX4#"," Add two vectors element-wise. ")
  , ("plusDoubleX2#"," Add two vectors element-wise. ")
  , ("plusFloatX8#"," Add two vectors element-wise. ")
  , ("plusDoubleX4#"," Add two vectors element-wise. ")
  , ("plusFloatX16#"," Add two vectors element-wise. ")
  , ("plusDoubleX8#"," Add two vectors element-wise. ")
  , ("minusInt8X16#"," Subtract two vectors element-wise. ")
  , ("minusInt16X8#"," Subtract two vectors element-wise. ")
  , ("minusInt32X4#"," Subtract two vectors element-wise. ")
  , ("minusInt64X2#"," Subtract two vectors element-wise. ")
  , ("minusInt8X32#"," Subtract two vectors element-wise. ")
  , ("minusInt16X16#"," Subtract two vectors element-wise. ")
  , ("minusInt32X8#"," Subtract two vectors element-wise. ")
  , ("minusInt64X4#"," Subtract two vectors element-wise. ")
  , ("minusInt8X64#"," Subtract two vectors element-wise. ")
  , ("minusInt16X32#"," Subtract two vectors element-wise. ")
  , ("minusInt32X16#"," Subtract two vectors element-wise. ")
  , ("minusInt64X8#"," Subtract two vectors element-wise. ")
  , ("minusWord8X16#"," Subtract two vectors element-wise. ")
  , ("minusWord16X8#"," Subtract two vectors element-wise. ")
  , ("minusWord32X4#"," Subtract two vectors element-wise. ")
  , ("minusWord64X2#"," Subtract two vectors element-wise. ")
  , ("minusWord8X32#"," Subtract two vectors element-wise. ")
  , ("minusWord16X16#"," Subtract two vectors element-wise. ")
  , ("minusWord32X8#"," Subtract two vectors element-wise. ")
  , ("minusWord64X4#"," Subtract two vectors element-wise. ")
  , ("minusWord8X64#"," Subtract two vectors element-wise. ")
  , ("minusWord16X32#"," Subtract two vectors element-wise. ")
  , ("minusWord32X16#"," Subtract two vectors element-wise. ")
  , ("minusWord64X8#"," Subtract two vectors element-wise. ")
  , ("minusFloatX4#"," Subtract two vectors element-wise. ")
  , ("minusDoubleX2#"," Subtract two vectors element-wise. ")
  , ("minusFloatX8#"," Subtract two vectors element-wise. ")
  , ("minusDoubleX4#"," Subtract two vectors element-wise. ")
  , ("minusFloatX16#"," Subtract two vectors element-wise. ")
  , ("minusDoubleX8#"," Subtract two vectors element-wise. ")
  , ("timesInt8X16#"," Multiply two vectors element-wise. ")
  , ("timesInt16X8#"," Multiply two vectors element-wise. ")
  , ("timesInt32X4#"," Multiply two vectors element-wise. ")
  , ("timesInt64X2#"," Multiply two vectors element-wise. ")
  , ("timesInt8X32#"," Multiply two vectors element-wise. ")
  , ("timesInt16X16#"," Multiply two vectors element-wise. ")
  , ("timesInt32X8#"," Multiply two vectors element-wise. ")
  , ("timesInt64X4#"," Multiply two vectors element-wise. ")
  , ("timesInt8X64#"," Multiply two vectors element-wise. ")
  , ("timesInt16X32#"," Multiply two vectors element-wise. ")
  , ("timesInt32X16#"," Multiply two vectors element-wise. ")
  , ("timesInt64X8#"," Multiply two vectors element-wise. ")
  , ("timesWord8X16#"," Multiply two vectors element-wise. ")
  , ("timesWord16X8#"," Multiply two vectors element-wise. ")
  , ("timesWord32X4#"," Multiply two vectors element-wise. ")
  , ("timesWord64X2#"," Multiply two vectors element-wise. ")
  , ("timesWord8X32#"," Multiply two vectors element-wise. ")
  , ("timesWord16X16#"," Multiply two vectors element-wise. ")
  , ("timesWord32X8#"," Multiply two vectors element-wise. ")
  , ("timesWord64X4#"," Multiply two vectors element-wise. ")
  , ("timesWord8X64#"," Multiply two vectors element-wise. ")
  , ("timesWord16X32#"," Multiply two vectors element-wise. ")
  , ("timesWord32X16#"," Multiply two vectors element-wise. ")
  , ("timesWord64X8#"," Multiply two vectors element-wise. ")
  , ("timesFloatX4#"," Multiply two vectors element-wise. ")
  , ("timesDoubleX2#"," Multiply two vectors element-wise. ")
  , ("timesFloatX8#"," Multiply two vectors element-wise. ")
  , ("timesDoubleX4#"," Multiply two vectors element-wise. ")
  , ("timesFloatX16#"," Multiply two vectors element-wise. ")
  , ("timesDoubleX8#"," Multiply two vectors element-wise. ")
  , ("divideFloatX4#"," Divide two vectors element-wise. ")
  , ("divideDoubleX2#"," Divide two vectors element-wise. ")
  , ("divideFloatX8#"," Divide two vectors element-wise. ")
  , ("divideDoubleX4#"," Divide two vectors element-wise. ")
  , ("divideFloatX16#"," Divide two vectors element-wise. ")
  , ("divideDoubleX8#"," Divide two vectors element-wise. ")
  , ("quotInt8X16#"," Rounds towards zero element-wise. ")
  , ("quotInt16X8#"," Rounds towards zero element-wise. ")
  , ("quotInt32X4#"," Rounds towards zero element-wise. ")
  , ("quotInt64X2#"," Rounds towards zero element-wise. ")
  , ("quotInt8X32#"," Rounds towards zero element-wise. ")
  , ("quotInt16X16#"," Rounds towards zero element-wise. ")
  , ("quotInt32X8#"," Rounds towards zero element-wise. ")
  , ("quotInt64X4#"," Rounds towards zero element-wise. ")
  , ("quotInt8X64#"," Rounds towards zero element-wise. ")
  , ("quotInt16X32#"," Rounds towards zero element-wise. ")
  , ("quotInt32X16#"," Rounds towards zero element-wise. ")
  , ("quotInt64X8#"," Rounds towards zero element-wise. ")
  , ("quotWord8X16#"," Rounds towards zero element-wise. ")
  , ("quotWord16X8#"," Rounds towards zero element-wise. ")
  , ("quotWord32X4#"," Rounds towards zero element-wise. ")
  , ("quotWord64X2#"," Rounds towards zero element-wise. ")
  , ("quotWord8X32#"," Rounds towards zero element-wise. ")
  , ("quotWord16X16#"," Rounds towards zero element-wise. ")
  , ("quotWord32X8#"," Rounds towards zero element-wise. ")
  , ("quotWord64X4#"," Rounds towards zero element-wise. ")
  , ("quotWord8X64#"," Rounds towards zero element-wise. ")
  , ("quotWord16X32#"," Rounds towards zero element-wise. ")
  , ("quotWord32X16#"," Rounds towards zero element-wise. ")
  , ("quotWord64X8#"," Rounds towards zero element-wise. ")
  , ("remInt8X16#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remInt16X8#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remInt32X4#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remInt64X2#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remInt8X32#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remInt16X16#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remInt32X8#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remInt64X4#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remInt8X64#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remInt16X32#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remInt32X16#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remInt64X8#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remWord8X16#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remWord16X8#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remWord32X4#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remWord64X2#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remWord8X32#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remWord16X16#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remWord32X8#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remWord64X4#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remWord8X64#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remWord16X32#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remWord32X16#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("remWord64X8#"," Satisfies @('quot#' x y) 'times#' y 'plus#' ('rem#' x y) == x@. ")
  , ("negateInt8X16#"," Negate element-wise. ")
  , ("negateInt16X8#"," Negate element-wise. ")
  , ("negateInt32X4#"," Negate element-wise. ")
  , ("negateInt64X2#"," Negate element-wise. ")
  , ("negateInt8X32#"," Negate element-wise. ")
  , ("negateInt16X16#"," Negate element-wise. ")
  , ("negateInt32X8#"," Negate element-wise. ")
  , ("negateInt64X4#"," Negate element-wise. ")
  , ("negateInt8X64#"," Negate element-wise. ")
  , ("negateInt16X32#"," Negate element-wise. ")
  , ("negateInt32X16#"," Negate element-wise. ")
  , ("negateInt64X8#"," Negate element-wise. ")
  , ("negateFloatX4#"," Negate element-wise. ")
  , ("negateDoubleX2#"," Negate element-wise. ")
  , ("negateFloatX8#"," Negate element-wise. ")
  , ("negateDoubleX4#"," Negate element-wise. ")
  , ("negateFloatX16#"," Negate element-wise. ")
  , ("negateDoubleX8#"," Negate element-wise. ")
  , ("indexInt8X16Array#"," Read a vector from specified index of immutable array. ")
  , ("indexInt16X8Array#"," Read a vector from specified index of immutable array. ")
  , ("indexInt32X4Array#"," Read a vector from specified index of immutable array. ")
  , ("indexInt64X2Array#"," Read a vector from specified index of immutable array. ")
  , ("indexInt8X32Array#"," Read a vector from specified index of immutable array. ")
  , ("indexInt16X16Array#"," Read a vector from specified index of immutable array. ")
  , ("indexInt32X8Array#"," Read a vector from specified index of immutable array. ")
  , ("indexInt64X4Array#"," Read a vector from specified index of immutable array. ")
  , ("indexInt8X64Array#"," Read a vector from specified index of immutable array. ")
  , ("indexInt16X32Array#"," Read a vector from specified index of immutable array. ")
  , ("indexInt32X16Array#"," Read a vector from specified index of immutable array. ")
  , ("indexInt64X8Array#"," Read a vector from specified index of immutable array. ")
  , ("indexWord8X16Array#"," Read a vector from specified index of immutable array. ")
  , ("indexWord16X8Array#"," Read a vector from specified index of immutable array. ")
  , ("indexWord32X4Array#"," Read a vector from specified index of immutable array. ")
  , ("indexWord64X2Array#"," Read a vector from specified index of immutable array. ")
  , ("indexWord8X32Array#"," Read a vector from specified index of immutable array. ")
  , ("indexWord16X16Array#"," Read a vector from specified index of immutable array. ")
  , ("indexWord32X8Array#"," Read a vector from specified index of immutable array. ")
  , ("indexWord64X4Array#"," Read a vector from specified index of immutable array. ")
  , ("indexWord8X64Array#"," Read a vector from specified index of immutable array. ")
  , ("indexWord16X32Array#"," Read a vector from specified index of immutable array. ")
  , ("indexWord32X16Array#"," Read a vector from specified index of immutable array. ")
  , ("indexWord64X8Array#"," Read a vector from specified index of immutable array. ")
  , ("indexFloatX4Array#"," Read a vector from specified index of immutable array. ")
  , ("indexDoubleX2Array#"," Read a vector from specified index of immutable array. ")
  , ("indexFloatX8Array#"," Read a vector from specified index of immutable array. ")
  , ("indexDoubleX4Array#"," Read a vector from specified index of immutable array. ")
  , ("indexFloatX16Array#"," Read a vector from specified index of immutable array. ")
  , ("indexDoubleX8Array#"," Read a vector from specified index of immutable array. ")
  , ("readInt8X16Array#"," Read a vector from specified index of mutable array. ")
  , ("readInt16X8Array#"," Read a vector from specified index of mutable array. ")
  , ("readInt32X4Array#"," Read a vector from specified index of mutable array. ")
  , ("readInt64X2Array#"," Read a vector from specified index of mutable array. ")
  , ("readInt8X32Array#"," Read a vector from specified index of mutable array. ")
  , ("readInt16X16Array#"," Read a vector from specified index of mutable array. ")
  , ("readInt32X8Array#"," Read a vector from specified index of mutable array. ")
  , ("readInt64X4Array#"," Read a vector from specified index of mutable array. ")
  , ("readInt8X64Array#"," Read a vector from specified index of mutable array. ")
  , ("readInt16X32Array#"," Read a vector from specified index of mutable array. ")
  , ("readInt32X16Array#"," Read a vector from specified index of mutable array. ")
  , ("readInt64X8Array#"," Read a vector from specified index of mutable array. ")
  , ("readWord8X16Array#"," Read a vector from specified index of mutable array. ")
  , ("readWord16X8Array#"," Read a vector from specified index of mutable array. ")
  , ("readWord32X4Array#"," Read a vector from specified index of mutable array. ")
  , ("readWord64X2Array#"," Read a vector from specified index of mutable array. ")
  , ("readWord8X32Array#"," Read a vector from specified index of mutable array. ")
  , ("readWord16X16Array#"," Read a vector from specified index of mutable array. ")
  , ("readWord32X8Array#"," Read a vector from specified index of mutable array. ")
  , ("readWord64X4Array#"," Read a vector from specified index of mutable array. ")
  , ("readWord8X64Array#"," Read a vector from specified index of mutable array. ")
  , ("readWord16X32Array#"," Read a vector from specified index of mutable array. ")
  , ("readWord32X16Array#"," Read a vector from specified index of mutable array. ")
  , ("readWord64X8Array#"," Read a vector from specified index of mutable array. ")
  , ("readFloatX4Array#"," Read a vector from specified index of mutable array. ")
  , ("readDoubleX2Array#"," Read a vector from specified index of mutable array. ")
  , ("readFloatX8Array#"," Read a vector from specified index of mutable array. ")
  , ("readDoubleX4Array#"," Read a vector from specified index of mutable array. ")
  , ("readFloatX16Array#"," Read a vector from specified index of mutable array. ")
  , ("readDoubleX8Array#"," Read a vector from specified index of mutable array. ")
  , ("writeInt8X16Array#"," Write a vector to specified index of mutable array. ")
  , ("writeInt16X8Array#"," Write a vector to specified index of mutable array. ")
  , ("writeInt32X4Array#"," Write a vector to specified index of mutable array. ")
  , ("writeInt64X2Array#"," Write a vector to specified index of mutable array. ")
  , ("writeInt8X32Array#"," Write a vector to specified index of mutable array. ")
  , ("writeInt16X16Array#"," Write a vector to specified index of mutable array. ")
  , ("writeInt32X8Array#"," Write a vector to specified index of mutable array. ")
  , ("writeInt64X4Array#"," Write a vector to specified index of mutable array. ")
  , ("writeInt8X64Array#"," Write a vector to specified index of mutable array. ")
  , ("writeInt16X32Array#"," Write a vector to specified index of mutable array. ")
  , ("writeInt32X16Array#"," Write a vector to specified index of mutable array. ")
  , ("writeInt64X8Array#"," Write a vector to specified index of mutable array. ")
  , ("writeWord8X16Array#"," Write a vector to specified index of mutable array. ")
  , ("writeWord16X8Array#"," Write a vector to specified index of mutable array. ")
  , ("writeWord32X4Array#"," Write a vector to specified index of mutable array. ")
  , ("writeWord64X2Array#"," Write a vector to specified index of mutable array. ")
  , ("writeWord8X32Array#"," Write a vector to specified index of mutable array. ")
  , ("writeWord16X16Array#"," Write a vector to specified index of mutable array. ")
  , ("writeWord32X8Array#"," Write a vector to specified index of mutable array. ")
  , ("writeWord64X4Array#"," Write a vector to specified index of mutable array. ")
  , ("writeWord8X64Array#"," Write a vector to specified index of mutable array. ")
  , ("writeWord16X32Array#"," Write a vector to specified index of mutable array. ")
  , ("writeWord32X16Array#"," Write a vector to specified index of mutable array. ")
  , ("writeWord64X8Array#"," Write a vector to specified index of mutable array. ")
  , ("writeFloatX4Array#"," Write a vector to specified index of mutable array. ")
  , ("writeDoubleX2Array#"," Write a vector to specified index of mutable array. ")
  , ("writeFloatX8Array#"," Write a vector to specified index of mutable array. ")
  , ("writeDoubleX4Array#"," Write a vector to specified index of mutable array. ")
  , ("writeFloatX16Array#"," Write a vector to specified index of mutable array. ")
  , ("writeDoubleX8Array#"," Write a vector to specified index of mutable array. ")
  , ("indexInt8X16OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexInt16X8OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexInt32X4OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexInt64X2OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexInt8X32OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexInt16X16OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexInt32X8OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexInt64X4OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexInt8X64OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexInt16X32OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexInt32X16OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexInt64X8OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexWord8X16OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexWord16X8OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexWord32X4OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexWord64X2OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexWord8X32OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexWord16X16OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexWord32X8OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexWord64X4OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexWord8X64OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexWord16X32OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexWord32X16OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexWord64X8OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexFloatX4OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexDoubleX2OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexFloatX8OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexDoubleX4OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexFloatX16OffAddr#"," Reads vector; offset in bytes. ")
  , ("indexDoubleX8OffAddr#"," Reads vector; offset in bytes. ")
  , ("readInt8X16OffAddr#"," Reads vector; offset in bytes. ")
  , ("readInt16X8OffAddr#"," Reads vector; offset in bytes. ")
  , ("readInt32X4OffAddr#"," Reads vector; offset in bytes. ")
  , ("readInt64X2OffAddr#"," Reads vector; offset in bytes. ")
  , ("readInt8X32OffAddr#"," Reads vector; offset in bytes. ")
  , ("readInt16X16OffAddr#"," Reads vector; offset in bytes. ")
  , ("readInt32X8OffAddr#"," Reads vector; offset in bytes. ")
  , ("readInt64X4OffAddr#"," Reads vector; offset in bytes. ")
  , ("readInt8X64OffAddr#"," Reads vector; offset in bytes. ")
  , ("readInt16X32OffAddr#"," Reads vector; offset in bytes. ")
  , ("readInt32X16OffAddr#"," Reads vector; offset in bytes. ")
  , ("readInt64X8OffAddr#"," Reads vector; offset in bytes. ")
  , ("readWord8X16OffAddr#"," Reads vector; offset in bytes. ")
  , ("readWord16X8OffAddr#"," Reads vector; offset in bytes. ")
  , ("readWord32X4OffAddr#"," Reads vector; offset in bytes. ")
  , ("readWord64X2OffAddr#"," Reads vector; offset in bytes. ")
  , ("readWord8X32OffAddr#"," Reads vector; offset in bytes. ")
  , ("readWord16X16OffAddr#"," Reads vector; offset in bytes. ")
  , ("readWord32X8OffAddr#"," Reads vector; offset in bytes. ")
  , ("readWord64X4OffAddr#"," Reads vector; offset in bytes. ")
  , ("readWord8X64OffAddr#"," Reads vector; offset in bytes. ")
  , ("readWord16X32OffAddr#"," Reads vector; offset in bytes. ")
  , ("readWord32X16OffAddr#"," Reads vector; offset in bytes. ")
  , ("readWord64X8OffAddr#"," Reads vector; offset in bytes. ")
  , ("readFloatX4OffAddr#"," Reads vector; offset in bytes. ")
  , ("readDoubleX2OffAddr#"," Reads vector; offset in bytes. ")
  , ("readFloatX8OffAddr#"," Reads vector; offset in bytes. ")
  , ("readDoubleX4OffAddr#"," Reads vector; offset in bytes. ")
  , ("readFloatX16OffAddr#"," Reads vector; offset in bytes. ")
  , ("readDoubleX8OffAddr#"," Reads vector; offset in bytes. ")
  , ("writeInt8X16OffAddr#"," Write vector; offset in bytes. ")
  , ("writeInt16X8OffAddr#"," Write vector; offset in bytes. ")
  , ("writeInt32X4OffAddr#"," Write vector; offset in bytes. ")
  , ("writeInt64X2OffAddr#"," Write vector; offset in bytes. ")
  , ("writeInt8X32OffAddr#"," Write vector; offset in bytes. ")
  , ("writeInt16X16OffAddr#"," Write vector; offset in bytes. ")
  , ("writeInt32X8OffAddr#"," Write vector; offset in bytes. ")
  , ("writeInt64X4OffAddr#"," Write vector; offset in bytes. ")
  , ("writeInt8X64OffAddr#"," Write vector; offset in bytes. ")
  , ("writeInt16X32OffAddr#"," Write vector; offset in bytes. ")
  , ("writeInt32X16OffAddr#"," Write vector; offset in bytes. ")
  , ("writeInt64X8OffAddr#"," Write vector; offset in bytes. ")
  , ("writeWord8X16OffAddr#"," Write vector; offset in bytes. ")
  , ("writeWord16X8OffAddr#"," Write vector; offset in bytes. ")
  , ("writeWord32X4OffAddr#"," Write vector; offset in bytes. ")
  , ("writeWord64X2OffAddr#"," Write vector; offset in bytes. ")
  , ("writeWord8X32OffAddr#"," Write vector; offset in bytes. ")
  , ("writeWord16X16OffAddr#"," Write vector; offset in bytes. ")
  , ("writeWord32X8OffAddr#"," Write vector; offset in bytes. ")
  , ("writeWord64X4OffAddr#"," Write vector; offset in bytes. ")
  , ("writeWord8X64OffAddr#"," Write vector; offset in bytes. ")
  , ("writeWord16X32OffAddr#"," Write vector; offset in bytes. ")
  , ("writeWord32X16OffAddr#"," Write vector; offset in bytes. ")
  , ("writeWord64X8OffAddr#"," Write vector; offset in bytes. ")
  , ("writeFloatX4OffAddr#"," Write vector; offset in bytes. ")
  , ("writeDoubleX2OffAddr#"," Write vector; offset in bytes. ")
  , ("writeFloatX8OffAddr#"," Write vector; offset in bytes. ")
  , ("writeDoubleX4OffAddr#"," Write vector; offset in bytes. ")
  , ("writeFloatX16OffAddr#"," Write vector; offset in bytes. ")
  , ("writeDoubleX8OffAddr#"," Write vector; offset in bytes. ")
  , ("indexInt8ArrayAsInt8X16#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexInt16ArrayAsInt16X8#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexInt32ArrayAsInt32X4#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexInt64ArrayAsInt64X2#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexInt8ArrayAsInt8X32#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexInt16ArrayAsInt16X16#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexInt32ArrayAsInt32X8#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexInt64ArrayAsInt64X4#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexInt8ArrayAsInt8X64#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexInt16ArrayAsInt16X32#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexInt32ArrayAsInt32X16#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexInt64ArrayAsInt64X8#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexWord8ArrayAsWord8X16#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexWord16ArrayAsWord16X8#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexWord32ArrayAsWord32X4#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexWord64ArrayAsWord64X2#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexWord8ArrayAsWord8X32#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexWord16ArrayAsWord16X16#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexWord32ArrayAsWord32X8#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexWord64ArrayAsWord64X4#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexWord8ArrayAsWord8X64#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexWord16ArrayAsWord16X32#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexWord32ArrayAsWord32X16#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexWord64ArrayAsWord64X8#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexFloatArrayAsFloatX4#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexDoubleArrayAsDoubleX2#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexFloatArrayAsFloatX8#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexDoubleArrayAsDoubleX4#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexFloatArrayAsFloatX16#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("indexDoubleArrayAsDoubleX8#"," Read a vector from specified index of immutable array of scalars; offset is in scalar elements. ")
  , ("readInt8ArrayAsInt8X16#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readInt16ArrayAsInt16X8#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readInt32ArrayAsInt32X4#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readInt64ArrayAsInt64X2#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readInt8ArrayAsInt8X32#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readInt16ArrayAsInt16X16#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readInt32ArrayAsInt32X8#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readInt64ArrayAsInt64X4#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readInt8ArrayAsInt8X64#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readInt16ArrayAsInt16X32#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readInt32ArrayAsInt32X16#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readInt64ArrayAsInt64X8#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readWord8ArrayAsWord8X16#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readWord16ArrayAsWord16X8#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readWord32ArrayAsWord32X4#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readWord64ArrayAsWord64X2#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readWord8ArrayAsWord8X32#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readWord16ArrayAsWord16X16#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readWord32ArrayAsWord32X8#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readWord64ArrayAsWord64X4#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readWord8ArrayAsWord8X64#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readWord16ArrayAsWord16X32#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readWord32ArrayAsWord32X16#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readWord64ArrayAsWord64X8#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readFloatArrayAsFloatX4#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readDoubleArrayAsDoubleX2#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readFloatArrayAsFloatX8#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readDoubleArrayAsDoubleX4#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readFloatArrayAsFloatX16#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("readDoubleArrayAsDoubleX8#"," Read a vector from specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeInt8ArrayAsInt8X16#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeInt16ArrayAsInt16X8#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeInt32ArrayAsInt32X4#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeInt64ArrayAsInt64X2#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeInt8ArrayAsInt8X32#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeInt16ArrayAsInt16X16#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeInt32ArrayAsInt32X8#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeInt64ArrayAsInt64X4#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeInt8ArrayAsInt8X64#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeInt16ArrayAsInt16X32#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeInt32ArrayAsInt32X16#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeInt64ArrayAsInt64X8#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeWord8ArrayAsWord8X16#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeWord16ArrayAsWord16X8#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeWord32ArrayAsWord32X4#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeWord64ArrayAsWord64X2#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeWord8ArrayAsWord8X32#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeWord16ArrayAsWord16X16#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeWord32ArrayAsWord32X8#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeWord64ArrayAsWord64X4#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeWord8ArrayAsWord8X64#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeWord16ArrayAsWord16X32#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeWord32ArrayAsWord32X16#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeWord64ArrayAsWord64X8#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeFloatArrayAsFloatX4#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeDoubleArrayAsDoubleX2#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeFloatArrayAsFloatX8#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeDoubleArrayAsDoubleX4#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeFloatArrayAsFloatX16#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("writeDoubleArrayAsDoubleX8#"," Write a vector to specified index of mutable array of scalars; offset is in scalar elements. ")
  , ("indexInt8OffAddrAsInt8X16#"," Reads vector; offset in scalar elements. ")
  , ("indexInt16OffAddrAsInt16X8#"," Reads vector; offset in scalar elements. ")
  , ("indexInt32OffAddrAsInt32X4#"," Reads vector; offset in scalar elements. ")
  , ("indexInt64OffAddrAsInt64X2#"," Reads vector; offset in scalar elements. ")
  , ("indexInt8OffAddrAsInt8X32#"," Reads vector; offset in scalar elements. ")
  , ("indexInt16OffAddrAsInt16X16#"," Reads vector; offset in scalar elements. ")
  , ("indexInt32OffAddrAsInt32X8#"," Reads vector; offset in scalar elements. ")
  , ("indexInt64OffAddrAsInt64X4#"," Reads vector; offset in scalar elements. ")
  , ("indexInt8OffAddrAsInt8X64#"," Reads vector; offset in scalar elements. ")
  , ("indexInt16OffAddrAsInt16X32#"," Reads vector; offset in scalar elements. ")
  , ("indexInt32OffAddrAsInt32X16#"," Reads vector; offset in scalar elements. ")
  , ("indexInt64OffAddrAsInt64X8#"," Reads vector; offset in scalar elements. ")
  , ("indexWord8OffAddrAsWord8X16#"," Reads vector; offset in scalar elements. ")
  , ("indexWord16OffAddrAsWord16X8#"," Reads vector; offset in scalar elements. ")
  , ("indexWord32OffAddrAsWord32X4#"," Reads vector; offset in scalar elements. ")
  , ("indexWord64OffAddrAsWord64X2#"," Reads vector; offset in scalar elements. ")
  , ("indexWord8OffAddrAsWord8X32#"," Reads vector; offset in scalar elements. ")
  , ("indexWord16OffAddrAsWord16X16#"," Reads vector; offset in scalar elements. ")
  , ("indexWord32OffAddrAsWord32X8#"," Reads vector; offset in scalar elements. ")
  , ("indexWord64OffAddrAsWord64X4#"," Reads vector; offset in scalar elements. ")
  , ("indexWord8OffAddrAsWord8X64#"," Reads vector; offset in scalar elements. ")
  , ("indexWord16OffAddrAsWord16X32#"," Reads vector; offset in scalar elements. ")
  , ("indexWord32OffAddrAsWord32X16#"," Reads vector; offset in scalar elements. ")
  , ("indexWord64OffAddrAsWord64X8#"," Reads vector; offset in scalar elements. ")
  , ("indexFloatOffAddrAsFloatX4#"," Reads vector; offset in scalar elements. ")
  , ("indexDoubleOffAddrAsDoubleX2#"," Reads vector; offset in scalar elements. ")
  , ("indexFloatOffAddrAsFloatX8#"," Reads vector; offset in scalar elements. ")
  , ("indexDoubleOffAddrAsDoubleX4#"," Reads vector; offset in scalar elements. ")
  , ("indexFloatOffAddrAsFloatX16#"," Reads vector; offset in scalar elements. ")
  , ("indexDoubleOffAddrAsDoubleX8#"," Reads vector; offset in scalar elements. ")
  , ("readInt8OffAddrAsInt8X16#"," Reads vector; offset in scalar elements. ")
  , ("readInt16OffAddrAsInt16X8#"," Reads vector; offset in scalar elements. ")
  , ("readInt32OffAddrAsInt32X4#"," Reads vector; offset in scalar elements. ")
  , ("readInt64OffAddrAsInt64X2#"," Reads vector; offset in scalar elements. ")
  , ("readInt8OffAddrAsInt8X32#"," Reads vector; offset in scalar elements. ")
  , ("readInt16OffAddrAsInt16X16#"," Reads vector; offset in scalar elements. ")
  , ("readInt32OffAddrAsInt32X8#"," Reads vector; offset in scalar elements. ")
  , ("readInt64OffAddrAsInt64X4#"," Reads vector; offset in scalar elements. ")
  , ("readInt8OffAddrAsInt8X64#"," Reads vector; offset in scalar elements. ")
  , ("readInt16OffAddrAsInt16X32#"," Reads vector; offset in scalar elements. ")
  , ("readInt32OffAddrAsInt32X16#"," Reads vector; offset in scalar elements. ")
  , ("readInt64OffAddrAsInt64X8#"," Reads vector; offset in scalar elements. ")
  , ("readWord8OffAddrAsWord8X16#"," Reads vector; offset in scalar elements. ")
  , ("readWord16OffAddrAsWord16X8#"," Reads vector; offset in scalar elements. ")
  , ("readWord32OffAddrAsWord32X4#"," Reads vector; offset in scalar elements. ")
  , ("readWord64OffAddrAsWord64X2#"," Reads vector; offset in scalar elements. ")
  , ("readWord8OffAddrAsWord8X32#"," Reads vector; offset in scalar elements. ")
  , ("readWord16OffAddrAsWord16X16#"," Reads vector; offset in scalar elements. ")
  , ("readWord32OffAddrAsWord32X8#"," Reads vector; offset in scalar elements. ")
  , ("readWord64OffAddrAsWord64X4#"," Reads vector; offset in scalar elements. ")
  , ("readWord8OffAddrAsWord8X64#"," Reads vector; offset in scalar elements. ")
  , ("readWord16OffAddrAsWord16X32#"," Reads vector; offset in scalar elements. ")
  , ("readWord32OffAddrAsWord32X16#"," Reads vector; offset in scalar elements. ")
  , ("readWord64OffAddrAsWord64X8#"," Reads vector; offset in scalar elements. ")
  , ("readFloatOffAddrAsFloatX4#"," Reads vector; offset in scalar elements. ")
  , ("readDoubleOffAddrAsDoubleX2#"," Reads vector; offset in scalar elements. ")
  , ("readFloatOffAddrAsFloatX8#"," Reads vector; offset in scalar elements. ")
  , ("readDoubleOffAddrAsDoubleX4#"," Reads vector; offset in scalar elements. ")
  , ("readFloatOffAddrAsFloatX16#"," Reads vector; offset in scalar elements. ")
  , ("readDoubleOffAddrAsDoubleX8#"," Reads vector; offset in scalar elements. ")
  , ("writeInt8OffAddrAsInt8X16#"," Write vector; offset in scalar elements. ")
  , ("writeInt16OffAddrAsInt16X8#"," Write vector; offset in scalar elements. ")
  , ("writeInt32OffAddrAsInt32X4#"," Write vector; offset in scalar elements. ")
  , ("writeInt64OffAddrAsInt64X2#"," Write vector; offset in scalar elements. ")
  , ("writeInt8OffAddrAsInt8X32#"," Write vector; offset in scalar elements. ")
  , ("writeInt16OffAddrAsInt16X16#"," Write vector; offset in scalar elements. ")
  , ("writeInt32OffAddrAsInt32X8#"," Write vector; offset in scalar elements. ")
  , ("writeInt64OffAddrAsInt64X4#"," Write vector; offset in scalar elements. ")
  , ("writeInt8OffAddrAsInt8X64#"," Write vector; offset in scalar elements. ")
  , ("writeInt16OffAddrAsInt16X32#"," Write vector; offset in scalar elements. ")
  , ("writeInt32OffAddrAsInt32X16#"," Write vector; offset in scalar elements. ")
  , ("writeInt64OffAddrAsInt64X8#"," Write vector; offset in scalar elements. ")
  , ("writeWord8OffAddrAsWord8X16#"," Write vector; offset in scalar elements. ")
  , ("writeWord16OffAddrAsWord16X8#"," Write vector; offset in scalar elements. ")
  , ("writeWord32OffAddrAsWord32X4#"," Write vector; offset in scalar elements. ")
  , ("writeWord64OffAddrAsWord64X2#"," Write vector; offset in scalar elements. ")
  , ("writeWord8OffAddrAsWord8X32#"," Write vector; offset in scalar elements. ")
  , ("writeWord16OffAddrAsWord16X16#"," Write vector; offset in scalar elements. ")
  , ("writeWord32OffAddrAsWord32X8#"," Write vector; offset in scalar elements. ")
  , ("writeWord64OffAddrAsWord64X4#"," Write vector; offset in scalar elements. ")
  , ("writeWord8OffAddrAsWord8X64#"," Write vector; offset in scalar elements. ")
  , ("writeWord16OffAddrAsWord16X32#"," Write vector; offset in scalar elements. ")
  , ("writeWord32OffAddrAsWord32X16#"," Write vector; offset in scalar elements. ")
  , ("writeWord64OffAddrAsWord64X8#"," Write vector; offset in scalar elements. ")
  , ("writeFloatOffAddrAsFloatX4#"," Write vector; offset in scalar elements. ")
  , ("writeDoubleOffAddrAsDoubleX2#"," Write vector; offset in scalar elements. ")
  , ("writeFloatOffAddrAsFloatX8#"," Write vector; offset in scalar elements. ")
  , ("writeDoubleOffAddrAsDoubleX4#"," Write vector; offset in scalar elements. ")
  , ("writeFloatOffAddrAsFloatX16#"," Write vector; offset in scalar elements. ")
  , ("writeDoubleOffAddrAsDoubleX8#"," Write vector; offset in scalar elements. ")
  ]
